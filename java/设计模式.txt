
创建型模式：单例、原型、建造者、工厂
结构型模式：适配器、桥接、组合、装饰器、外观、代理、享元
行为型模式：责任链、命令、迭代器、中介者、备忘录、解释器、状态、策略、模板方法、访问者、观察者

原型模式
复制现有对象来创建新对象，而不是使用实例化

装饰器
基于接口，使用组合而非继承的模式，动态地拓展功能

外观
为一组接口提供一个统一、简单的高层接口，隐藏了子系统的复杂性。比如吃饭，正常调用买菜、洗菜、做饭等一系列复杂接口，使用外观模式，只需要调用下单接口

代理和装饰器的区别
两者在结构上很接近，代理的重点是隐藏被代理对象；装饰器的重点是拓展原有功能

责任链
如名称，将请求的处理者连成一个链条，每个处理者可以自己处理请求，也可以交给下一个处理者。常见于审批流程

策略
定义一个策略接口，用来表示算法。有若干实现类。上下文根据客户端选择不同的策略，避免修改代码。一般和工厂模式共同使用
java中集合类的排序器Comparator就是策略模式，定义一个排序接口，由客户端自行实现，无需修改Comparator本身代码
常用于支付方式选择、优惠券选择等

设计模式背后的思想
封装变化：将可能变化的地方独立出来，不要和不变的地方混合在一起。比如策略模式、模板方法模式
开闭原则：对拓展开发，对修改关闭。有新需求时，不修改原有的代码，而是通过拓展实现。比如装饰器模式
依赖倒置原则：高层模块不应依赖具体的底层依赖，而是依赖抽象；抽象不应依赖细节，细节应依赖抽象
单一职责原则：一个类应只有一个引起它变化的原因，即一个类只负责一个职责
组合复用原则：尽量使用组合或聚合，而不是继承
里氏替换原则：子类可以在任意地方替换父类，而不影响功能。长方形为父类，正方形为子类，显然不符合该原则
迪米特法则：也叫最少知道原则，一个对象应对其他对象有最少了解，即一个类应减少与其他类的直接交互。比如学生-班级-学校三个类，学校有遍历全部学生的方法。不符合法则的写法：学校的方法内部，使用两个for循环遍历。正确的写法：班级提供遍历学生的方法A，学校使用一个for循环调用A
快速记忆：SOLID。s=single单一职责；o=open开闭原则；l=里氏替换；i=interface接口隔离，客户端不应该依赖不需要的接口；d=dependencies依赖倒置
