
基础数据类型及占用字节数
byte	1	8位有符号整数
short	2	16位有符号整数
int	    4	32位有符号整数
long	8	64位有符号整数
float	4	32位单精度浮点数
double	8	64位双精度浮点数
boolean	1	布尔类型（实际实现可能不同）
char	2	16位Unicode字符

String的实现
jdk8及之前，保存在char[]数组，char采用UTF-16编码，能保存大部分字符
jdk9开始，保存为byte[]+编码标志（比如Latin-1 单字节编码，UTF-16）
改动原因：大量string仅包含英文、数字，本可以用一个字节保存，但用了char保存，浪费了50%空间。故jdk9中，若string仅包含Latin-1字符时，采用Latin-1；若包含中文、emoji等，采用UTF-16

java创建对象的几种方式
new，反射，clone，反序列化。前两个会调用构造方法，后两个不会。其中反序列化需要对象实现serializable接口（这是一个空接口），通过ObjectInputStream.readObject方法创建

transient的作用
序列化时忽视

0.1*3和0.3是否相等
不，java默认使用double保存，0.1和0.3都无法精确表示

a=a+b和a+=b的区别
a为short，b为int，相加时会隐式地将short提升为int，即结果为int。a=a+b会报错，无法用short接收int；a+=b会将结果强制转化为short，不会报错

try catch finally及return的执行顺序
先执行try或catch，在return前保存结果，执行finally，再返回之前保存的结果（基本数据类型是保存值，对象则保存引用）。但若finally中return，则不会返回之前保存的记过

IO流
可分为输入流和输出流，也可分为字符流和字节流
字节流：（以字节为单位，8 位，可处理所有数据）
    基类：InputStream，OutputStream
    常用子类（节点流：直接操作数据源）：
        FileInputStream / FileOutputStream：读写文件的字节流
        ByteArrayInputStream / ByteArrayOutputStream：读写内存中字节数组的流
        PipedInputStream / PipedOutputStream：管道字节流，用于多线程间通信
    常用处理流（包装节点流，增强功能）
        BufferedInputStream / BufferedOutputStream：缓冲字节流
        PrintStream：打印字节流，方便输出各种数据类型（如print()、println()），System.out就是PrintStream实例
字符流（以字符为单位，16 位，仅处理文本数据，涉及编码）
    基类：Reader，Writer
    常用子类（节点流）
    FileReader / FileWriter：读写文件的字符流
    CharArrayReader / CharArrayWriter：读写内存中字符数组的流
    StringReader / StringWriter：读写字符串的字符流
    BufferedReader / BufferedWriter：缓冲字符流，提高文本读写效率，BufferedReader提供readLine()方法
    InputStreamReader / OutputStreamWriter：转换流（字节流→字符流的桥梁），可指定编码（如UTF-8）
    PrintWriter：打印字符流，功能类似PrintStream，但更适合处理文本，支持指定编码

Object常用的方法
wait，配置sync关键字，一个线程在获取锁后，执行wait方法会手动释放锁，等待其他线程唤醒它。notify，配合sync关键字，唤醒wait的某个线程（但此时没有释放锁，只是通知其他线程可以抢锁了）。notifyall，唤醒全部线程。

实现两个线程交替执行
while循环里执行业务代码，然后notify，然后wait。循环外notify。

fail-fast
java集合的一种错误机制，多个线程同时操作同一个集合对象时，可能产生fail-fast事件，抛出异常。遍历前记录modCount（记录集合修改的次数），遍历时比较该值是否有改变，有则说明被修改，抛异常。

进程通信的方式：共享存储、消息传递、管道通信
消息传递：直接通信（点到点发送，通过send和receive原语，每个进程维护消息缓冲队列）和间接通信（广播信箱为中介，类似消息队列）
管道通信：管道的本质是一个共享pipe文件，是内存中固定大小的缓冲区
进程的状态：ready、running、blocked、new、terminated。上面5种为线程活跃（alive）时的状态，此外还有挂起（suspend）和激活（active）两个原语用于控制进程。

shutdown hook
java允许在jvm关闭时执行一些操作（比如释放资源），代码类似于
public static void main(String[] args) {
    Runtime.getRuntime().addShutdownHook(new Thread(() -> {
        System.out.println("释放资源");
    }));
}
很多操作都会触发shutdown hook，比如：1.kill -15 2.代码正常执行完毕 3.System.exit(int status)
kill -9不会触发shutdown hook

同步异步、阻塞非阻塞的关系
比如说a方法调b方法
同步：a主动等待b返回
异步：a不用等待，通过轮询、异步回调等方式得到b的返回
阻塞：b方法执行的这段时间里，a方法被挂起
非阻塞：b方法执行的这段时间里，a方法不被挂起，可以做其他事

同步阻塞：平时的编程大部分都是同步阻塞
异步非阻塞：一般结合回调，b方法执行完成后通知a方法
同步非阻塞：一般通过轮询实现。a方法每隔一段时间查询b方法的返回值

常见的java开发规范
任何锁都要设置超时时间避免系统直接卡死
数据库DTO使用包装类而不是基本数据类型
异常不要用来做流程控制，异常的处理效率比分支低
方法先检查非主干的逻辑，以免嵌套过多
禁止for循环里写sql
日志打印敏感信息要脱敏

单机版定时任务如何实现
1.基于java自带的timer/timerTask。使用简单，单线程执行（如果run方法执行很久，本来应该执行下一次任务了，会被阻塞）
Timer timer = new Timer();
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        System.out.println("Task executed at: " + new Date());
    }
}, 1000, 2000); // 延迟1s后执行，之后每2s执行一次
2.基于java自带的ScheduledExecutorService，支持多个任务并发执行
提供了schedule（一次性）、scheduleAtFixedRate、scheduleWithFixedDelay等主要方法
比如间隔1s，任务执行4秒
scheduleAtFixedRate每4秒执行一次，即按照上一个任务开始时间来计算下一个任务开始时间，【上一个任务结束后】才判断是否到了下一个任务的开始时间
scheduleWithFixedDelay每5秒执行一次，按上一个任务的结束时间来计算
3.spring框架的@Scheduled，如下
@Scheduled(fixedRate = 2000)
public void executeTask() {}
支持多种配置方式：
fixedRate：固定频率执行
fixedDelay：固定延迟执行
cron表达式：复杂时间调度
