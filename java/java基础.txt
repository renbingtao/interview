
========================java基础========================

java创建对象的几种方式
new，反射，clone，反序列化。前两个会调用构造方法，后两个不会。其中反序列化需要对象实现serializable接口（这是一个空接口），通过ObjectInputStream.readObject方法创建

transient的作用
序列化时忽视

0.1*3和0.3是否相等
不，java默认使用double保存，0.1和0.3都无法精确表示

a=a+b和a+=b的区别
a为short，b为int，相加时会隐式地将short提升为int，即结果为int。a=a+b会报错，无法用short接收int；a+=b会将结果强制转化为short，不会报错

try catch finally及return的执行顺序
先执行try或catch，在return前保存结果，执行finally，再返回之前保存的结果（基本数据类型是保存值，对象则保存引用）。但若finally中return，则不会返回之前保存的记过

IO流
可分为输入流和输出流，也可分为字符流和字节流。

Object常用的方法
wait，配置sync关键字，一个线程在获取锁后，执行wait方法会手动释放锁，等待其他线程唤醒它。notify，配合sync关键字，唤醒wait的某个线程（但此时没有释放锁，只是通知其他线程可以抢锁了）。notifyall，唤醒全部线程。

实现两个线程交替执行
while循环里执行业务代码，然后notify，然后wait。循环外notify。

fail-fast
java集合的一种错误机制，多个线程同时操作同一个集合对象时，可能产生fail-fast事件，抛出异常。遍历前记录modCount（记录集合修改的次数），遍历时比较该值是否有改变，有则说明被修改，抛异常。

concurrentHashMap原理
java8之前，分段锁，分成16个段，每个段内部是一个小的hashmap，对段操作时需要先获取锁，因此并发最多为16
8及之后采用cas+synchronized关键字
get方法：
调用spread方法重新计算hash值，原hash异或（00/11=1，01/10=0）原hash右移16位，再与0x7fffffff（二进制为01111111等）与运算来保证hash值为正数，因为hash为负数有特殊的作用（表示这个node为红黑树）
计算下标，但不是通过table[i]获取，而是通过Unsafe类的方法getObjectVolatile来获取最新的值（数组为volatile Node<K,V> table，volatile并不能保证数据内的元素的修改可见性。此外一个不加volatile关键字的数据，也可以通过Unsafe的这个方法获取最新值）
比较头结点的key及hash，即数据元素的第一个值，相同则返回
若头结点的hash<0，则代表node为红黑树（TreeBin为Node的子类，重写了find方法及其他对红黑树的操作方法，红黑树的节点为TreeNode类），调用find方法获取值
按照链表的方式遍历（node为单向）
put方法：
内部是一个死循环，方法内大量if elseif elseif else
if：数组为空，则初始化
elseif：头节点为空，新建node并通过cas替换，替换成功则退出循环
elseif:头节点的hash=-1，则说明正在扩容中，将旧的头节点替换为新的头结点
else:获取sync锁（锁为头节点），头节点hash>=0时，进入子循环：比较hash及key，相等则替换val，不等则继续比较下一个，为空则新建node，直到退出子循环。每循环一次，binCount（默认0的int）都会++
                            头节点为红黑树时，调用红黑树的方法插入
                            释放sync锁，检查若binCount>=8，则转为TreeBin。若有旧值，则返回旧值
ifelse已结束，且没有旧值，更新map的总数，检查是否需要扩容，最后返回null

cas锁
比较并交换值，这是一个系统底层的原子方法，不可分割的

线程池的生命周期
创建：没有任务运行
运行：任务提交到线程池
关闭：不再接收新任务，但已有的任务继续执行（包括阻塞队列中的任务）
终止：所有任务执行完毕

并发与并行
并发：单核处理器在多个程序之间快速切换
并行：同一时刻多个任务同时执行，需要多核处理器

进程通信的方式：共享存储、消息传递、管道通信
消息传递：直接通信（点到点发送，通过send和receive原语，每个进程维护消息缓冲队列）和间接通信（广播信箱为中介，类似消息队列）
管道通信：管道的本质是一个共享pipe文件，是内存中固定大小的缓冲区
进程的状态：ready、running、blocked、new、terminated。上面5种为线程活跃（alive）时的状态，此外还有挂起（suspend）和激活（active）两个原语用于控制进程。

shutdown hook
java允许在jvm关闭时执行一些操作（比如释放资源），代码类似于
public static void main(String[] args) {
    Runtime.getRuntime().addShutdownHook(new Thread(() -> {
        System.out.println("释放资源");
    }));
}
很多操作都会触发shutdown hook，比如：1.kill -15 2.代码正常执行完毕 3.System.exit(int status)
kill -9不会触发shutdown hook

同步异步、阻塞非阻塞的关系
比如说a方法调b方法
同步：a主动等待b返回
异步：a不用等待，通过轮询、异步回调等方式得到b的返回
阻塞：b方法执行的这段时间里，a方法被挂起
非阻塞：b方法执行的这段时间里，a方法不被挂起，可以做其他事

同步阻塞：平时的编程大部分都是同步阻塞
异步非阻塞：一般结合回调，b方法执行完成后通知a方法
同步非阻塞：一般通过轮询实现。a方法每隔一段时间查询b方法的返回值

========================多线程及并发========================

创建线程的方式
继承Thread并重写run方法
实现Runnable接口并作为参数传给thread
实现Callable接口并作为参数传给FutureTask，再把FutureTask传递给thread
线程池创建任务实现Runnable或Callable

如何停止一个正在运行的线程
使用自定义的标识，即正常退出；stop强行停止，已废弃；interrupt，设置标志位，线程并不会立即停止，而是在合适的时机检查标志位

java线程池中常用的队列有哪些
下面三个都是guc下的
ArrayBlockingQueue，基于数组的有界阻塞队列，FIFO，创建时指定大小，线程安全，通过add（抛异常）、offer（返回false）、put（线程被阻塞直到有空位）方法插入元素，括号内为队列满时的处理方式；通过poll（返回null）、take（线程等待）获取并移除头部的元素
LinkedBlockingQueue，基于链表的有界或可选无界的阻塞队列，FIFO，不指定容量时为整数最大值
SynchronousQueue，特殊的队列，容量为0，元素直接从生产者给消费者，无缓冲。Executors.newCachedThreadPool()内部就使用了该队列，适合大量短期异步任务，潜在问题是允许创建的线程无上线，可能耗尽系统资源。应用场景：线程之间直接传递数据，没有延迟

threadLocal
threadLocalMap包含多个entry，Entry继承了WeakReference<ThreadLocal<?>>，构造方法为Entry(ThreadLocal<?> k, Object v) {super(k);value = v;}。注意这里的super(k)调用了WeakReference的构造函数，使得key为弱引用。value则是强引用
使用弱引用的原因：若使用强引用，threadLocal对象的引用设置为null时，threadLocalMap仍指向了threadLocal对象，导致不会回收，使用弱引用则会正常回收
内存泄露的条件：1.threadlocal对象被回收（比如没有使用static修饰，在非静态方法内部创建，方法执行完毕后被jvm回收） 2.value没有被手动清理 3.线程长期存活
内存泄露的原因：threadlocal对象被回收后，map的key为null，但WeakReference仍存在，则value也存在，生命周期和线程一致。所以使用完threadLocal后，要调用remove清除键值对。另外线程可能复用，若不清除，线程下次复用时，threadLocal仍保存之前的值，导致混乱

线程池
线程池的核心机制是对线程的复用，即一个线程执行完任务后，线程本身不会被销毁，则其内部的成员变量的值（比如ThreadLocalMap，子类的私有变量）会被保留，线程id也会保留，再次执行任务时，这些成员变量仍会保持上一次执行的状态

AQS
一个抽象类，位于guc的Lock包下，为锁和同步器提供了通用的框架。提供了排他锁和共享锁、公平锁和非公平锁等制。使用了int类型的state变量记录锁竞争的状态，不同子类实现中有不同的含义
在reentrantLock中，state 0表示没有线程竞争锁资源，>=1表示有线程持有锁
线程获取锁时，若state=0，使用cas更新为1，多个线程同时抢锁时，抢锁失败的线程会调用Unsafe.park方法进行阻塞，打包成node节点（双向链表，FIFO，包含Thread属性），插入到链表的末尾；锁释放后，会唤醒双向链表头一个阻塞的线程（并不是头节点，头节点是傀儡节点）
公平锁和非公平锁的区别：两者在获取锁时都会判断state是否为0，公平锁还会判断队列中是否有阻塞的线程，然后cas一次进行抢锁

========================设计模式========================

创建型模式：单例、原型、建造者、工厂
结构型模式：适配器、桥接、组合、装饰器、外观、代理、享元
行为型模式：责任链、命令、迭代器、中介者、备忘录、解释器、状态、策略、模板方法、访问者、观察者

原型模式
复制现有对象来创建新对象，而不是使用实例化

装饰器
基于接口，使用组合而非继承的模式，动态地拓展功能

外观
为一组接口提供一个统一、简单的高层接口，隐藏了子系统的复杂性。比如吃饭，正常调用买菜、洗菜、做饭等一系列复杂接口，使用外观模式，只需要调用下单接口

代理和装饰器的区别
两者在结构上很接近，代理的重点是隐藏被代理对象；装饰器的重点是拓展原有功能

责任链
如名称，将请求的处理者连成一个链条，每个处理者可以自己处理请求，也可以交给下一个处理者。常见于审批流程

策略
定义一个策略接口，用来表示算法。有若干实现类。上下文根据客户端选择不同的策略，避免修改代码
java中集合类的排序器Comparator就是策略模式，定义一个排序接口，由客户端自行实现，无需修改Comparator本身代码
常用于支付方式选择、优惠券选择等

设计模式背后的思想
封装变化：将可能变化的地方独立出来，不要和不变的地方混合在一起。比如策略模式、模板方法模式
开闭原则：对拓展开发，对修改关闭。有新需求时，不修改原有的代码，而是通过拓展实现。比如装饰器模式
依赖倒置原则：高层模块不应依赖具体的底层依赖，而是依赖抽象；抽象不应依赖细节，细节应依赖抽象
单一职责原则：一个类应只有一个引起它变化的原因，即一个类只负责一个职责
组合复用原则：尽量使用组合或聚合，而不是继承
里氏替换原则：子类可以在任意地方替换父类，而不影响功能。长方形为父类，正方形为子类，显然不符合该原则
迪米特法则：也叫最少知道原则，一个对象应对其他对象有最少了解，即一个类应减少与其他类的直接交互。比如学生-班级-学校三个类，学校有遍历全部学生的方法。不符合法则的写法：学校的方法内部，使用两个for循环遍历。正确的写法：班级提供遍历学生的方法A，学校使用一个for循环调用A
