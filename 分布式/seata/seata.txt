
==================== seata服务器的下载 ====================

https://seata.apache.org/download/seata-server/

==================== 概述 ====================

一个分布式的全局事务，整体是 两阶段提交 的模型。全局事务是由若干分支事务组成的，分支事务要满足 两阶段提交 的模型要求，即需要每个分支事务都具备自己的：
一阶段 prepare 行为
二阶段 commit 或 rollback 行为
根据两阶段行为模式的不同，我们将分支事务划分为AT和TCC

AT 模式基于 支持本地 ACID 事务 的 关系型数据库：
一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录。
二阶段 commit 行为：马上成功结束，自动 异步批量清理回滚日志。
二阶段 rollback 行为：通过回滚日志，自动 生成补偿操作，完成数据回滚。

相应的，TCC 模式，不依赖于底层数据资源的事务支持：
一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。
二阶段 commit 行为：调用 自定义 的 commit 逻辑。
二阶段 rollback 行为：调用 自定义 的 rollback 逻辑。

==================== 空回滚和悬挂 ====================

空回滚：try的时候，有的分支成功，有的失败，而所有分支都要cancel，所以cancel需要能够识别try是否成功，如果try失败了或根本没有执行try，则本地回滚就是一次空回滚
事务悬挂：某分支事务的try请求在网络中拥堵，其他分支事务失败，触发cancel；cancel请求先到达，执行空回滚，try请求后到达，锁定资源，导致try占用的资源一直被锁定，无法释放

以上的两个问题，可以用一个方案解决：引入分布式事务的记录表，主要包含tr_id和state字段。在执行try和cancel时，都需要创建或修改记录
try：先根据tr_id查询，若有记录且状态为cancel，则放弃执行try
cancel：先根据tr_id查询，若没有记录则插入一条记录，状态为cancel
但上述过程都需要加分布式锁

==================== 主要概念 ====================

分支事务
各个微服务对自己的数据库执行的事务
全局事务
分支事务的汇总

事务协调者TC
管理全局、分支事务的状态，协调各分支事务的提交或回滚。通常是独立部署的中心化服务

事务管理器TM
定义全局事务的范围：开始全局事务、提交或回滚全局事务。TM嵌入到业务系统中，是分布式事务的入口

资源管理器RM
管理分支事务处理的资源，报告给TC分支事务的状态，驱动分支事务提交或回滚

全局事务创建：TM向TC注册全局事务，TC分配一个全局事务ID（XID）
分支事务注册：每个分支事务通过RM向TC注册
协调提交/回滚：根据全局事务的状态，通知RM提交或回滚分支事务

举例：A服务通过RPC调用B服务；B会写db然后调用C服务；C服务也会写db；然后A再调D服务。则A是TM，BCD是RM，seata服务器是TC

具体配置
引入依赖spring-cloud-starter-alibaba-seata
添加seata的配置文件file.conf，主要内容如下
service {
    vgroupMapping.default_tx_group = "default" //seata服务器的分组名
    default.grouplist = "127.0.0.1:8091" //TC的端口
}
在全局事务的方法上加@GlobalTransactional注解

seata AT模式的二阶段提交
注解注册全局事务，TM调用TC，生成XID，全局事务开始
第一阶段：执行分支事务
    先查询前镜像（通过where查询修改前的数据），会获取本地锁
    执行sql
    查询后镜像（根据id查询修改后的数据）
    将前后镜像写入undo_log表中
    注册分支事务，申请记录的全局锁
    本地事务提交：业务数据及undo_log一起持久化保存
    向TC汇报结果
第二阶段：分支提交/回滚
    所有分支成功：TC通知所有分支提交，由于各分支本地事务已提交，因此直接返回ok
    TC创建一个异步任务，任务会批量删除undo_log记录
    任一分支失败：TC通知所有分支回滚，分支开启本地事务：
        根据XID，branchId在undo_log表中查询数据
        数据校验：后镜像和当前数据比较，正常情况是一致的；如果不一致且开启了数据校验（默认开启），则执行配置的策略（默认会抛异常，需要人工介入处理）
        数据一致时，回滚数据：把数据更新为前镜像，删除undo_log
    无论成功还是失败，最后都要释放全局锁

四种事物模式（分支的事务模式）
AT：即auto，由seata自动控制，默认。最终一致性，因此会出现短暂的数据不一致。要求由数据库的权限，因为要新增undo_log表
XA：遵循XA协议，以XA协议的机制来管理分支事务。XA在第一阶段不会提交，而是阻塞，在第二阶段才是真正提交。seata服务器作为TM，应用作为RM。强一致性，性能差，适合金融、支付等场景
TCC：即try confirm cancel三个方法，由程序员手动实现逻辑。性能好，会出现数据不一致的状态
Saga：长事务解决方案，整合消息队列，实现最终一致性，适用于短时间无法完成的事务，比如单据审批

==================== 全局锁 ====================
全局锁不是mysql的写锁，而是由seata管理的，可以通过seata的管理台查看

全局锁的主要字段
xid+branchid+lockkey 作为唯一索引
lockkey格式为 表名:主键1=值1，比如user:id=1001

全局锁的申请放在本地事务提交前而不是在查询镜像前申请的原因：
1.全局锁可能造成阻塞，尽可能减少持有时间
2.对于自增id，需要在执行insert后才能获取。因此只能在sql执行后获取全局锁

==================== 事务隔离 ====================

脏写举例
分布式事务A要更新ab两个库，本地事务B要更新a库
1.A更新a库并提交
2.B更新a库并提交
3.A出现异常，要回滚，发现实际数据和后镜像的内容不一致（即发生了脏写），无法全局回滚
如何防止脏写
方案1：事务B也加上@GlobalTransactional，在提交时无法申请到全局锁，抛异常
方案2：@GlobalLock + select for update
@GlobalLock的作用是向Seata申请全局锁（不开启全局事务）

