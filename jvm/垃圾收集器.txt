
=============对象已死？=============

可达性分析
gc root节点包括虚拟机栈中引用的对象，类对象，常量，class对象等，有时也包含其他临时对象
从这些节点开始，根据引用关系向下搜索，所走过的路径称为引用链，若某个对象到GC ROOT没有任何引用链相连，则该对象不可达

强软弱虚
软，在oom之前进行回收；弱，gc时回收；虚，对象被回收时发送系统通知

=============垃圾收集算法=============

分代收集理论
该理论建立在两个假设之上：
1.大部分对象是朝生夕灭
2.熬过越多次gc，则对象越难以回收
依次，多数垃圾收集器都认为应该把堆划分为不同的区域，依据对象的年龄分配到不同区域，根据不同区域的特征采用匹配的收集算法

标记复制
各50%，改进811+逃生门设计。主要用于新生代回收

标记清除
标记所有要回收的对象，然后统一回收。产生碎片，大部分对象回收时效率低，主要用于老生代回收。CMS收集器的实现方式（关注延迟）

标记整理
让存活的对象向一端移动。在老年代中移动存活对象是很重的操作，但从整个程序的吞吐量来看，移动对象是划算的

=============hotspot实现细节=============

根节点枚举
这一步一定会STW，哪怕是cms、g1、zgc
类加载完成时，hotspot会把对象内xx偏移量是xx类似的数据计算出来，保存在一组称为oopmap的数据结构中，这样收集器可以直接得到哪些地方存在对象引用

安全点
可能引起oopmap发生变化的指令非常多，如果执行每条指令都生成oopmap，则耗费大量内存
jvm执行到特定的指令（安全点）时，会根据帧栈的状态生成对应的oopmap，记录了帧栈中哪些位置包含了引用
安全点的选择标准为程序是否会长时间运行，一般为方法调用，循环跳转，异常跳转等

安全区域
安全区域指的是某一段代码中，引用关系不会发生变化，因此在该区域的任意位置都可以开始垃圾收集。可以看作区间版的安全点

记忆集与卡表
为了避免把整个老年代加入gc root扫描范围，引入了记忆集remembered set，它记录了从【非收集区域】指向【收集区域】的指针集合，是一种抽象，具体实现是卡表
卡表是用byte数组实现的，元素称为卡页，对应内存中固定大小（512字节）的内存块。如果卡页内的对象存在跨代指针，则数组元素的值标记为1（变脏）。变脏是通过写屏障实现的。gc时，把脏的元素也加入到gc root节点
G1收集器中，具体实现为哈希表，记录了其他region指向自己的指针。key为其他region的编号，value为一个集合，元素为其他region的卡表的索引号，即哪些卡页包含跨region引用

三色标记法
白色：未被垃圾回收器访问。可达性分析刚开始时，所有对象都是白色。分析结束时，仍是白色的对象表示不可达
黑色：对象已经被垃圾回收器访问，且该对象的所有字段都已遍历完成。黑色对象不会被回收，且不会被扫描
灰色：对象已经被垃圾回收器访问，但该对象至少有一个字段还没有遍历到。灰色对象是标记过程的中间态，是黑色对象和白色对象的分界线，最终所有对象只能为白色或黑色
标记过程：一开始所有对象都是白色。遍历gc root节点，标记为黑，把它们全部的字段标记为灰色。把灰色对象标记为黑，把它们白色的字段标记为灰，重复这个过程。最终所有的灰色对象都变为黑色
可能的问题：a->b->c 其中a是黑色，b是灰色，c是白色。标记过程中，用户修改了引用关系，b->c断了，且a->c，则c最终是白色（b不会扫描到c，a是黑色只扫描一次），不应该被回收的对象被回收
理论已经证明，同时存在两个条件时，会发生黑色对象变白的问题：
1.有一个或多个黑色对象的字段指向白色对象
2.灰色或白色对象到该白色对象的全部直接或间接引用都被删除
因此有了两种解决方案：
1.增量更新，破坏第一个条件，即黑色指向白色时，记录下来，扫描结束后，将记录下来的对象重新扫描一次。CMS的实现
2.原始快照，破坏第二个条件，即无论是否删除引用关系，都按照刚开始扫描的那一刻的快照来搜索。G1的实现

=============经典垃圾收集器=============

下列6种收集器中，新生代全都是标记-复制，老年代CMS采用标记-清除，其他全都是标记-整理

serial收集器
最基础、古老的收集器，单线程，客户端默认的新生代收集器。优点：额外内存消耗少，适合桌面应用的场景

serialOld收集器
serial的老年代版本，单线程，标记整理，供客户端使用

parNew收集器
serial的多线程版

CMS收集器
标记清除，gc过程包括：初始标记，并发标记，重新标记，并发清除。初始标记是标记gc root能直接关联的对象，会stw；并发标记是从gc root对象遍历整个对象图的过程，时间较长但不会stw；重新标记会修正并发标记期间用户进程操作可能导致的标记变动，会stw；并发清除不会stw。
在并发标记和并发清除阶段，用户进程还在进行，会产生新的垃圾，因此不是老年代几乎满了时gc，而是92%（java6）时gc。若预留的空间不足以分配新对象，会出现并发失败（Concurrent Mode Failure），改用serial old进行垃圾收集

Parallel Scavenge收集器
java8默认的新生代收集器

Parallel Old收集器
java8默认的老年代收集器，和Parallel Scavenge配合，主要服务于对吞吐量要求高、对延迟不敏感的场景。 吞吐量=用于代码运行时间/（用于代码运行时间 + gc时间）

G1收集器
cms的继承人，不再基于新生代或老年代，而是衡量堆的哪块内存里的垃圾最多。g1把堆分为多个大小相等的独立空间（region）。每个region可以扮演不同的角色，比如eden区、survivor区，或者老年代，g1根据不同角色采用不同策略
g1保留了新生代、老年代的概念，但他们是不连续的动态集合。TAMS是两个指针，preTAMS和nextTAMS
gc过程包括初始标记，并发标记，最终标记，筛选回收
初始标记：stw，标记gc root能直接关联的对象
并发标记：从gc root进行可达性分析，与用户进程同时进行，耗时较长
最终标记：stw，处理SATB记录
筛选回收：对各region的回收价值和成本进行排序，筛选回收价值最大的region集合，根据用户期望的停顿时间，选择任意多个region，将旧region的存活对象复制到空的region中

ZGC收集器
和g1一样，也是基于region（官方称为page）布局，但region是动态的，有大、中、小三种容量
小型：2M，保存<256kb的对象
中型：32M，保存>=256kb且<4M的对象
大型：大小不固定，但必须是2MB的倍数，保存>=4M的对象
染色指针
在从前，如果要在对象上保存jvm本身需要的数据，通常放在对象头中。但很多时候不希望访问对象，又能得到这些数据（比如三色标记法，关注对象的引用关系而非对象本身），zgc采用了染色指针，即直接把这些数据保存在引用对象的指针上
64位linux系统实际只有46位是用来寻址的。zgc使用4位作为标志位（即42位用来寻址，因此ZGC最多支持2的42次方=4TB的内存）
4个标志位：2个表示三色标记状态，1个表示是否进入了重分配集（即被移动过），1个表示是否只能通过finalize方法访问
使用染色指针前，还要解决一个问题：jvm如何定义指针的某些位作为标志位？操作系统寻址时，是用整个指针寻址，而非其中某些位。某些硬件支持虚拟地址掩码，但在不支持的平台上（x86-64），则是通过虚拟内存映射解决
ZGC使用了【多重映射】将多个不同的虚拟内存地址映射到同一个物理内存地址上，是多对一的映射


=============内存分配与回收策略=============

对象优先在eden分配

大对象直接进入老年代
有一个jvm参数设定一个阈值，判断是否为大对象
若存活对象总和大于survivor区大小，也会直接放入老年代

长期存活的对象进入老年代

空间担保机制
minor gc之前，jvm会预估存活对象总大小（根据历次晋升到老年代对象的平均大小），判断老年代是否有足够的连续空间容纳这些对象。如果有足够空间则执行minor gc，否则触发full gc。jdk7之后取消了该参数，改为固定行为
