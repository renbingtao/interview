
=============对象已死？=============

可达性分析
gc root节点包括虚拟机栈中引用的对象，类对象，常量，class对象等，有时也包含其他临时对象
从这些节点开始，根据引用关系向下搜索，所走过的路径称为引用链，若某个对象到GC ROOT没有任何引用链相连，则该对象不可达

强软弱虚
软，在oom之前进行回收；弱，gc时回收；虚，对象被回收时发送系统通知

=============垃圾收集算法=============

分代收集理论
该理论建立在两个假设之上：
1.大部分对象是朝生夕灭
2.熬过越多次gc，则对象越难以回收
依次，多数垃圾收集器都认为应该把堆划分为不同的区域，依据对象的年龄分配到不同区域，根据不同区域的特征采用匹配的收集算法

标记复制
各50%，改进811+逃生门设计。主要用于新生代回收

标记清除
标记所有要回收的对象，然后统一回收。产生碎片，大部分对象回收时效率低，主要用于老生代回收。CMS收集器的实现方式（关注延迟）

标记整理
让存活的对象向一端移动。在老年代中移动存活对象是很重的操作，但从整个程序的吞吐量来看，移动对象是划算的

=============hotspot实现细节=============

根节点枚举
这一步一定会STW，哪怕是cms、g1、zgc
类加载完成时，hotspot会把对象内xx偏移量是xx类似的数据计算出来，保存在一组称为oopmap的数据结构中，这样收集器可以直接得到哪些地方存在对象引用

安全点
可能引起oopmap发生变化的指令非常多，如果执行每条指令都生成oopmap，则耗费大量内存
jvm执行到特定的指令（安全点）时，会根据帧栈的状态生成对应的oopmap，记录了帧栈中哪些位置包含了引用
安全点的选择标准为程序是否会长时间运行，一般为方法调用，循环跳转，异常跳转等

安全区域
安全区域指的是某一段代码中，引用关系不会发生变化，因此在该区域的任意位置都可以开始垃圾收集。可以看作区间版的安全点

记忆集与卡表
为了避免把整个老年代加入gc root扫描范围，引入了记忆集remembered set，它记录了从【非收集区域】指向【收集区域】的指针集合，是一种抽象，具体实现是卡表
卡表是用byte数组实现的，元素称为卡页，对应内存中固定大小（512字节）的内存块。如果卡页内的对象存在跨代指针，则数组元素的值标记为1（变脏）。变脏是通过写屏障实现的。gc时，把脏的元素也加入到gc root节点
G1收集器中，具体实现为哈希表，记录了其他region指向自己的指针。key为其他region的编号，value为一个集合，元素为其他region的卡表的索引号，即哪些卡页包含跨region引用

三色标记法
白色：未被垃圾回收器访问。可达性分析刚开始时，所有对象都是白色。分析结束时，仍是白色的对象表示不可达
黑色：对象已经被垃圾回收器访问，且该对象的所有字段都已遍历完成。黑色对象不会被回收，且不会被扫描
灰色：对象已经被垃圾回收器访问，但该对象至少有一个字段还没有遍历到。灰色对象是标记过程的中间态，是黑色对象和白色对象的分界线，最终所有对象只能为白色或黑色
标记过程：一开始所有对象都是白色。遍历gc root节点，标记为黑，把它们全部的字段标记为灰色。把灰色对象标记为黑，把它们白色的字段标记为灰，重复这个过程。最终所有的灰色对象都变为黑色
可能的问题：a->b->c 其中a是黑色，b是灰色，c是白色。标记过程中，用户修改了引用关系，b->c断了，且a->c，则c最终是白色（b不会扫描到c，a是黑色只扫描一次），不应该被回收的对象被回收
理论已经证明，同时存在两个条件时，会发生黑色对象变白的问题：
1.有一个或多个黑色对象的字段指向白色对象
2.灰色或白色对象到该白色对象的全部直接或间接引用都被删除
因此有了两种解决方案：
1.增量更新，破坏第一个条件，即黑色指向白色时，记录下来，扫描结束后，将记录下来的对象重新扫描一次。CMS的实现
2.原始快照，破坏第二个条件，即无论是否删除引用关系，都按照刚开始扫描的那一刻的快照来搜索。G1的实现

=============经典垃圾收集器=============

======新生代收集器======
全都是标记-复制算法

serial收集器
最基础、古老的收集器，单线程，客户端默认的新生代收集器。优点：额外内存消耗少，适合桌面应用的场景

parNew收集器
serial的多线程版

Parallel Scavenge收集器
java8默认的新生代收集器，目标是实现吞吐量的可控。吞吐量=用于代码运行时间/（用于代码运行时间 + gc时间）。收集器提供了两个参数：
一个控制最大停顿时间。收集器会尽可能控制gc的时间不超过预设值。但缩短停顿时间会牺牲吞吐量和新生代空间大小
一个控制吞吐量大小，是1-100的一个整数。

======老年代收集器======
CMS采用标记-清除，其他全都是标记-整理

serialOld收集器
serial的老年代版本，单线程，标记整理，供客户端使用

Parallel Old收集器
java8默认的老年代收集器，和Parallel Scavenge配合实现吞吐量优先的目标，主要服务于对吞吐量要求高、对延迟不敏感的场景

CMS收集器
目标是尽可能缩短停顿时间。gc过程如下
【初始标记】是标记gc root能直接关联的对象，会stw
【并发标记】是从gc root对象遍历整个对象图的过程，时间较长但不会stw
【重新标记】会修正并发标记期间用户进程操作可能导致的标记变动，会stw
【并发清除】不会stw
在并发标记和并发清除阶段，用户进程还在进行，会产生新的垃圾，因此不是老年代几乎满了时gc，而是92%（java6）时gc。若预留的空间不足以分配新对象，会出现并发失败（Concurrent Mode Failure），改用serial old进行垃圾收集

======G1收集器======
目标是实现停顿时间可控。cms的继承人，不再基于新生代或老年代，而是衡量堆的哪块内存里的垃圾最多
g1把堆分为多个大小相等的独立空间（region）。每个region可以扮演不同的角色，比如eden区、survivor区，或者老年代，g1根据不同角色采用不同策略。除此之外还有一个humongous region，专门保存大对象，按老年代处理
g1保留了新生代、老年代的概念，但他们是不连续的动态集合
垃圾回收过程中会不断产生新的垃圾，因此g1为每一个region设计了两个名为TAMS的指针（preTAMS和nextTAMS），把region的一部分空间划分出来用于新对象的分配。如果垃圾回收速度不如内存分配速度，则会导致full gc（类似cms的Concurrent Mode Failure）
gc过程如下
【初始标记】stw，标记gc root能直接关联的对象
【并发标记】从gc root进行可达性分析，与用户进程同时进行，耗时较长
【最终标记】stw，处理SATB记录
【筛选回收】对各region的回收价值和成本进行排序，筛选回收价值最大的region集合，根据用户期望的停顿时间，选择任意多个region，将旧region的存活对象复制到空的region中

=============低延迟垃圾收集器=============

垃圾收集器最重要的三个指标：内存占用、吞吐量、延迟。随着硬件的发展，延迟越来越重要（内存更大，gc耗费的时间更多）

ZGC收集器
jdk11作为实验特性引入，15作为正式特性
目标是实现回收任意大小堆的停顿时间都控制在10ms以内（停顿时间只与gc root大小相关而与堆大小无关）
zgc没有记忆集，也没有分代
和g1一样，也是基于region（官方称为page或Zpage）布局，但region是动态的，有大、中、小三种容量
小型：2M，保存<256kb的对象
中型：32M，保存>=256kb且<4M的对象
大型：大小不固定，但必须是2MB的倍数，保存>=4M的对象

染色指针
在从前，如果要在对象上保存jvm本身需要的数据，通常放在对象头中。但很多时候不希望访问对象，又能得到这些数据（比如三色标记法，关注对象的引用关系而非对象本身），zgc采用了染色指针，即直接把这些数据保存在引用对象的指针上
64位linux系统实际只有46位是用来寻址的。zgc使用4位作为标志位（即42位用来寻址，因此ZGC最多支持2的42次方=4TB的内存）
4个标志位：2个表示三色标记状态，1个表示是否进入了重分配集（即被移动过），1个表示是否只能通过finalize方法访问

多重映射
使用染色指针前，还要解决一个问题：jvm如何定义指针的某些位作为标志位？操作系统寻址时，是用整个指针寻址，而非其中某些位。某些硬件支持虚拟地址掩码，但在不支持的平台上（x86-64），则是通过虚拟内存映射解决
ZGC使用了多重映射将多个不同的虚拟内存地址映射到同一个物理内存地址上，是多对一的映射（在linux中是通过mmap实现的）
当程序创建对象时，zgc会申请三个虚拟内存（marked0，marked1，remapped）作为三个视图，同一时间只有一个生效
物理地址是不包含标志位的，标志位只属于虚拟地址
举例：三个视图Marked0是0x0000040012345678，Marked1是0x0000080012345678，Remapped是0x0000100012345678，这三个地址都映射到同一个物理地址0x0000000012345678

读屏障
类似aop的前置增强，当应用线程访问对象时，执行一段方法：判断对象地址视图==当前视图来决定是否进行重定位

gc过程
【初始标记】参考g1
【并发标记】可达性分析，但在指针上标记（更新Marked0、Marked1标志位）
【并发预重分配】扫描所有的region（即全堆），根据条件得到要清理哪些region，把它们组成【重分配集】
【并发重分配】核心阶段。把重分配集中的存活对象复制到新的region上，并为重分配集中的每个region维护一个转发表，记录从旧对象到新对象的转向关系
如果用户线程此时访问重分配集中的对象，则会被内存屏障截获，并根据转发表转发到新复制的对象上，并修正引用的值（使其指向新对象）。zgc将这种行为称为自愈能力
重分配集中的某个region复制完成后，该region就可以释放了，但转发表不能释放
【并发重映射】修正整个堆中指向重分配集中旧对象的所有引用。但这一步不是很迫切，因为旧引用可以自愈，所以这一步要做的事情，实际上是在下一次gc的【并发标记】中做的（因为并发标记要遍历所有对象，在遍历时顺带着修复指针，然后转发表就可以释放了）

======jdk21之后======
引入了分代zgc

=============内存分配与回收策略=============

对象优先在eden分配

大对象直接进入老年代
有一个jvm参数设定一个阈值，判断是否为大对象
若存活对象总和大于survivor区大小，也会直接放入老年代

长期存活的对象进入老年代

空间担保机制
minor gc之前，jvm会预估存活对象总大小（根据历次晋升到老年代对象的平均大小），判断老年代是否有足够的连续空间容纳这些对象。如果有足够空间则执行minor gc，否则触发full gc。jdk7之后取消了该参数，改为固定行为

================= 多重映射专题 =================
来自官网
https://wiki.openjdk.org/display/zgc/Pointer+Metadata+using+Multi-Mapped+memory

不使用多重映射的元数据位
传统的指针中所有的位都用来寻址。例如
                  Hex : Binary
Address bits: 0x13210 : 0001 0011 0010 0001 0000
Address bits: 0x23210 : 0010 0011 0010 0001 0000
其中0x13210和0x23210指向了两个不同的对象
如果想要在指针上包含元数据，则要把指针分为两部分：一部分指向对象的地址，一部分表示元数据。例如
Pointer value:     0x13210 : 0001 0011 0010 0001 0000
Metadata bits:     0x1     : 0001
Address bits:       0x3210 :      0011 0010 0001 0000

Pointer value:     0x23210 : 0010 0011 0010 0001 0000
Metadata bits:     0x2     : 0010
Address bits:       0x3210 :      0011 0010 0001 0000
在这个例子中，指针0x13210和0x23210指向了同一个对象0x3210，它们包含元数据位
在使用时，需要先移除元数据位得到地址位，然后访问。例如
// Pointer with 16 address bits
ptr_with_metadata = 0x13210;

// Remove metadata bits to get the address 0x3210
AddressBitsMask = ((1 << 16) - 1);
address = ptr_with_metadata & AddressBitsMask

// Dereference and use the object at the given address
use(*address)
这种操作会导致运行变慢


使用多重映射的元数据位
把两个示例指针的地址位和元数据位拆分。例如
Pointer value:         0x13210 : 0001 0011 0010 0001 0000
Address bits:           0x3210 :      0011 0010 0001 0000
Metadata bits:         0x10000 : 0001 0000 0000 0000 0000

Pointer value:         0x23210 : 0010 0011 0010 0001 0000
Address bits:           0x3210 :      0011 0010 0001 0000
Metadata bits:         0x20000 : 0010 0000 0000 0000 0000

然后，把同一块‘16 位地址对应的 64KB 内存’，映射到‘元数据位所指定的地址’作为起始的虚拟地址区域”
+-----------+ 0x10000 -----+
| Mapping 1 |               \
|           |                +---> +------------------------+
|           |               /      |                        |
+-----------+ 0x20000 -----+       | 64 KB allocated memory |
| Mapping 2 |                      |                        |
|           |                      +------------------------+
|           |
+-----------+ 0x30000
这里的64KB内存指的是物理内存；元数据位所指定的地址（0x10000、0x20000）是不能虚拟内存区域的起始地址

此时，指针中的‘地址位’会作为‘已分配物理内存’中的偏移量。所以 0x13210 和 0x23210 这两个指针，都会指向‘已分配内存区域中偏移量为 0x3210 字节’的那个对象
+-----------+ 0x10000
|           |
|        X  | 0x13210 -----+       +----------------------+
|           |               \      |                      |
+-----------+ 0x20000        +---> | X @ offset 0x3210    |
|           |               /      |                      |
|        X  | 0x23210 -----+       +----------------------+
|           |
+-----------+ 0x30000
即不管虚拟内存区域的起始地址是什么，只要偏移量（0x3210）相同，则都指向同一个物理内存
