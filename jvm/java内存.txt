=============运行时数据区域=============

1.程序计数器
不会内存溢出

2.java虚拟机栈
线程私有，生命周期与线程相同，存储局部变量表，操作数栈，动态连接，方法出口等。每个方法被调用到执行完毕，对应这帧栈在虚拟机栈中的入栈到出栈的过程。局部变量表保存了编译期间可知的基本数据类型及对象引用和returnAddress类型。
栈深度超过允许的最大值时stack overflow，栈扩容失败时oom。hotspot不允许动态扩容，即栈空间申请成功时不会oom，但申请时可能oom

3.本地方法栈
hot spot将虚拟机栈和本地方法栈合二为一

4.java堆
几乎所有对象实例及数组都应当在堆上分配。堆中划分出了多个线程私有的分配缓冲区TLAB（thread local allocation buffer）以提升对象分配的效率
通过-Xmx -Xms设置堆大小

5.方法区
存储类信息，常量，静态变量等，java7中位于堆内存；java8中使用元空间metaspace来实现，位于本地内存

6.运行时常量池
方法区的一部分。class文件包含一项【常量池表】，保存了编译期间生成的各种字面量与符号引用，这些内容在类加载后保存在【运行时常量池】
字面量：文本字符串、基本数据类型的值及final的常亮。比如String str="Hello"，则"Hello"是字面量
符号引用：类、接口的全限定名，字段名，方法名等
java运行期间也可以把新的常量放入池中，典型方法为String.intern()

7.直接内存
本地内存的子集，可能OOM，且不受jvm内存回收管理。-XX:MaxDirectMemorySize参数可以设置直接内存的最大值，默认和堆的最大值一致
传统的read需要先把数据从磁盘复制到内核缓冲区，再复制到java堆内存
NIO可以使用native函数库分配堆外内存，通过堆内的DirectByteBuffer对象进行操作，避免了在java堆和native堆之间来回复制数据

=============虚拟机对象=============

对象的内存布局
对象头，实例数据，对齐填充
对象头包括对象自身运行时的数据（闭合hashcode，gc分代年龄，锁状态标志，线程持有的锁等）和类型指针

对象的访问定位
句柄：堆中划分出一个内存区域，句柄池，池中的每一条记录都包含了指向对象实例数据的指针和指向对象类型数据的指针。对象引用指向的是句柄池中的记录。
好处：稳定，若对象被移动或回收，则只需修改池中的记录，无需修改引用。坏处：多了一次访问步骤，性能差
直接指针：引用直接指向对象的地址。hotsopt默认实现
