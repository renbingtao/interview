
========================jvm========================

jvm内存区域

程序计数器
不会内存溢出

java虚拟机栈
线程私有，生命周期与线程相同，存储局部变量表，操作数栈，动态连接，方法出口等。每个方法被调用到执行完毕，对应这帧栈在虚拟机栈中的入栈到出栈的过程。局部变量表保存了编译期间可知的基本数据类型及对象引用和returnAddress类型。
栈深度超过允许的最大值时stack overflow，栈扩容失败时oom。hotspot不允许动态扩容，即栈空间申请成功时不会oom，但申请时可能oom

本地方法栈
hot spot将虚拟机栈和本地方法栈合二为一

java堆
-Xmx -Xms

方法区
存储类信息，常亮，静态变量等，在java8中使用元空间meta-space来实现

运行时常量池
方法区的一部分，用于保存编译期生成的各种字面量和符号引用；字面量包括文本字符串、基本数据类型的值及final的常亮。比如String str="Hello"，则"Hello"是字面量。符号引用包括类、接口的全限定名，字段名，方法名等。向运行时常量池添加内容的常见方法是String.intern()

直接内存
NIO可以使用native函数库分配堆外内存，通过堆内的DirectByteBuffer对象进行操作，避免了在java堆和native堆之间来回复制数据

对象的内存布局
对象头，实例数据，对齐填充
对象头包括对象自身运行时的数据（闭合hashcode，gc分代年龄，锁状态标志，线程持有的锁等）和类型指针

对象的访问定位
句柄：堆中划分出一个内存区域，句柄池，池中的每一条记录都包含了指向对象实例数据的指针和指向对象类型数据的指针。对象引用指向的是句柄池中的记录。
好处：稳定，若对象被移动或回收，则只需修改池中的记录，无需修改引用。坏处：多了一次访问步骤，性能差
直接指针：引用直接指向对象的地址。hotsopt默认实现

可达性分析
gc root节点包括虚拟机栈中引用的对象，类对象，常量，class对象等，有时也包含其他临时对象

强软弱虚
软，在oom之前进行回收；弱，gc时回收；虚，对象被回收时发送系统通知

跨代引用
记忆集remembered set是抽象，卡表是具体实现。卡表每一个元素为卡页，512byte。卡表元素变脏是通过写屏障实现的

标记清除
标记所有要回收的对象，然后统一回收。产生碎片，大部分对象回收时效率低

标记复制
各50%，改进811+逃生门设计

标记整理
让存活的对象向一段移动。老年代很慢

根节点枚举
虚拟机通过oopmap的数据结构直接获取哪些存在对象引用：jvm执行到特定的指令（安全点）时，会根据帧栈的状态生成对应的oopmap，记录了帧栈中哪些位置包含了引用。

安全点
选择标准为程序是否会长时间运行，一般为方法调用，循环跳转，异常跳转等

空间担保机制
minor gc时，若存活对象总和大于survivor区大小，存活对象会直接放入老年代。minor gc之前，jvm会预估存活对象总和，判断老年代最大连续空间是否大于历次minor gc存活对象平均大小或新生代对象大小总和，大于任意一个就触发minor gc，否则触发major gc。jdk7之后取消了该参数，改为固定行为

serial收集器
单线程，客户端默认的新生代收集器。优点：额外内存消耗少，适合桌面应用的场景

parNew收集器
serial的多线程并行版

serialOld收集器
serial的老年代版本，单线程，标记整理，供客户端使用

CMS收集器
标记清除，gc过程包括：初始标记，并发标记，重新标记，并发清除。初始标记是标记gc root能直接关联的对象，会stw；并发标记是从gc root对象遍历整个对象图的过程，时间较长但不会stw；重新标记会修正并发标记期间用户进程操作可能导致的标记变动，会stw；并发清除不会stw。
在并发标记和并发清除阶段，用户进程还在进行，会产生新的垃圾，因此不是老年代几乎满了时gc，而是92%（java6）时gc。若预留的空间不足以分配新对象，会出现并发失败（Concurrent Mode Failure），改用serial old进行垃圾收集

G1收集器
cms的继承人，不再基于新生代或老年代，而是衡量堆的哪块内存里的垃圾最多。g1把堆分为多个大小相等的独立空间（region），每个堆可以是eden区、survivor区，也可以是老年代，g1根据不同角色采用不同策略。
g1保留了新生代、老年代的概念，但他们是不连续的动态集合。TAMS是两个指针，preTAMS和nextTAMS。gc过程包括初始标记，并发标记，最终标记，筛选回收。初始标记：stw，标记gc root能直接关联的对象；并发标记：从gc root进行可达性分析，与用户进程同时进行，耗时较长；最终标记：stw，处理SATB记录；筛选回收：对各region的回收价值和成本进行排序，筛选回收价值最大的region集合，根据用户期望的停顿时间，选择任意多个region，将旧region的存活对象复制到空的region中。

虚拟机类加载机制
类的生命周期：加载、验证、准备、解析、初始化、使用、卸载
加载：将class文件从磁盘或网络中读取到内存
验证：保证class文件符合jvm的规范
准备：为类中的静态变量分配内存并写0。比如static int a=123，则此时a=0，但如果加上final，则a=123
解析：将常量池内的符号引用转换为直接引用
初始化：执行类构造器（clinit方法），包括类变量的赋值和static{}只能访问之前定义的变量，对于之后定义的变量，可以赋值但不能访问。语句，编译器收集的顺序取决于源文件的顺序，static{}只能访问之前定义的变量，对于之后定义的变量，可以赋值但不能访问

classLoader：判断两个类是否相等，需要这两个类是由同一个类加载器加载的前提下，即即时两个类来自同一个class文件，被同一个jvm加载，只要是不同的classloader加载，那它们就不是相等的
三层类加载器：
启动类加载器bootstrap classloader，加载java_home/lib目录下的jar包；
扩展类加载器extension classloader，加载java_home/lib/ext目录下的jar包；
系统类加载器application classloader，加载classpath下的jar包。
双亲委派模型采用组合而非继承的方式实现，不会自己加载类，而是交给父类加载，父类无法加载时才会自己去加载。

java内存模型与线程
处理器的高速缓存与主内存通过MESI协议保持一致性。java内存模型规定了所有变量都应该存储在主内存上，每个线程也可以有自己的工作内存，其中保存了被该线程使用的变量的主内存副本，线程对变量的操作都必须在工作内存中进行，而不能直接操作主内存中的数据，线程间变量值的传递都需要通过主内存来完成。java内存模型定义了8中操作：lock,unlock,read,load,use,assign,store,write。

volatile
有两个作用，一是保证变量对所有线程的可见性，即对volatile变量的写操作会立刻反应到其他线程之中，volatile变量在各个线程中是一致的；二是禁止指令重排序。

实现线程（非java线程）有三种方式：使用内核线程实现（1:1），使用用户线程实现（1:N），使用用户线程+轻量级进程混合实现（N:M）。
内核线程由内核完成线程切换，每个内核线程可以视为内核的一个分身，程序一般不会直接使用内核线程，而是使用其高级接口：轻量级进程，即通常意义上的线程，由于轻量级进程会消耗内核资源（如内核线程的栈空间），因此一个系统支持的轻量级进程是有限的。java线程的实现通常采用轻量级进程，即1:1。
用户线程称为1：N实现，用户线程的建立、同步、销毁、调度完全在用户态中完成，所有的线程操作都需要用户程序自己处理，系统内核不能感知用户线程的存在。
混合实现称为N:M实现，将内核线程与用户线程一起使用，用户线程还是在用户空间，因此用户线程的创建、切换等操作依旧廉价，而轻量级进程则作为用户线程和内核线程之间的桥梁，可以使用内核的线程调度功能及处理器映射。

线程调度的方式一般有协同式和抢占式，协同式指线程执行完任务后通知系统切换到另一个线程；抢占式由系统为每个线程分配执行时间，也是java采用的方式，java语言提供了10个线程优先级，但由于主流jvm的线程都是映射到系统的原生线程，因此调度最终还是由系统决定，且系统的优先级不一定能和java中的优先级一一对应，因此这不是一种稳定的调节手段。java定义了6中线程状态：new，runnable（包括操作系统线程状态中的running和ready，即可能运行，也可能等待分配时间片），waiting（Object.wait，Thread.join，LockSupport.park），timed waiting（Thread.sleep），blocked，terminated。

互斥同步（悲观锁）
sync关键字编译后在同步块前后形成monitorenter和monitorexit两个指令。ReentrantLock(实现了Lock接口)增加了高级功能：等待可中断，公平锁（按申请时间获取锁，影响性能），绑定多个条件。

非阻塞同步（乐观锁）
需要硬件指令集来实现，保证看起来多个操作的行为只通过一条命令即可完成。x86执行使用cmpxchg完成CAS功能。ABA问题可以通过加入版本来解决，不过总的来说比较鸡肋，ABA最好通过sync或Lock解决。

无同步方案：一个方法不涉及共享数据，天生线程安全。比如可重入代码（相同的输入，得到相同的输出），线程本地存储。

sync锁优化
自旋锁与自适应自旋：获取不到锁时不会直接挂起，而是先自旋尝试获取，无法获取才挂起；自旋的时间不是固定的，而是由上一次的自旋时间及锁的持有者的状态决定。

锁消除
一些代码加了锁，通过逃逸分析，判断堆上的数据不会逃逸出去被其他线程访问，因此去掉锁。很多锁不是程序员加上的，比如String s=String s1+String s2+String s3，JDK5之前会转换为stringbuilder.append。解释执行（java编译器生成平台无关的字节码，解释器逐句翻译成机器码）时会加锁，但服务端编译器即时编译（JIT，运行过程中将热点代码hot spot编译成机器码）后会去掉锁。

锁粗化
继续使用上面的例子，反复对一个对象加锁和解锁，甚至在循环加锁，jvm会扩大加锁范围。

锁升级
对象头的mark word字段中，有3bit（2个标志位，1个偏向位）用于表示锁的状态。进程启动后前4秒创建的对象为无锁，后4秒创建的对象为可偏向但没偏向的锁。
获取锁时，若可偏向（标志位01，偏向位1），比较当前线程id是否位markword中记录的，若是则获取到偏向锁并执行同步方法；若不是则尝试通过cas获取。cas成功时更新线程id并执行同步方法；不成功时撤销偏向位（偏向位0），锁置为未锁定（标志位01）或轻量级锁（标志位00）。
加轻量级锁先将markword的内容复制到帧栈（可理解为快照），然后通过cas更新markword，成功则获取到轻量级锁；失败则升级为重量级锁。

sync和ReentrantLock的区别
sync无需手动释放锁及处理异常，lock需要释放并处理异常；sync是关键字，jvm后续版本可通过底层机制优化，lock主要通过代码实现，优化空间有限；lock可设置等待超时时间，支持公平锁（性能急剧下降），可绑定多个条件。

逃逸分析
hotspot会分析一个新对象的使用范围，决定把对象分配在堆或者栈上（不逃逸的对象可能分配在栈上）

标量替换
在逃逸分析的基础上的优化。对象由多个字段组成，这些字段可看为标量，不直接为对象分配内存，而是在栈上为标量分配空间

jvm主要组成部分
类加载子系统：根据全限定类名将class文件加载到运行时数据区
执行引擎：执行class指令
运行时数据区：平时说的jvm内存
本地接口组件：与本地库交互，是其他变成语言交互的接口

tomcat类加载机制：tomcat拓展了java类加载机制，引入了多个自定义的类加载器：
Common ClassLoader：加载tomcat本身，父类加载器是App ClassLoader
Catalina ClassLoader：加载tomcat需要的类，父类加载器是Common ClassLoader
Shared ClassLoader：加载所有Web应用共享的类和资源，父类加载器是Common ClassLoader
WebApp ClassLoader：每个应用有自己独立的WebApp ClassLoader，加载该应用自身的类，父类加载器是Shared ClassLoader
Jsp ClassLoader：每个JSP文件都有一个对应的ClassLoader，父类加载器是WebApp ClassLoader
WebApp ClassLoader打破了传统的双亲委派机制，会先自己加载，找不到时才让父类加载

类文件结构
class文件是一组以8字节为基础单位的二进制流，中间没有任何分隔符。当某数据项需要8字节以上的空间时，按照高位在前（大端对齐，比如要保存0x1234，高地址为0x12，低地址为0x34，即1234；小端对齐则高地址为0x34，低地址为0x12，即3412）的方式分割为若干个8字节进行存储
