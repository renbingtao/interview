
==========================================普通消息==========================================
适用于消息之间独立，无需关联的场景
生命周期
1.初始化（Initialized）：消息由生产者构建、初始化，准备发送到服务端
2.就绪（Ready）：消息成功发送到服务端，对消费者可见并可被消费
3.处理中（Inflight）：消息被消费者获取，根据消费者本地业务逻辑进行处理
在此过程中，服务端会等待消费者完成消费并提交消费结果。如果服务端在一定时间内未收到消费者响应，Apache RocketMQ 会对该消息进行重试
4.已确认（Acked）：消费者完成消费，并向服务端提交消费结果。服务端标记当前消息是否消费成功
Apache RocketMQ 默认保存所有消息。消费结果提交时，消息数据只是被逻辑标记为已消费，并不会立即删除。因此，消费者可以在消息因保存时间过期或存储空间不足被删除前，进行消息回溯重新消费
5.已删除（Deleted）：当消息保存时间到期或存储空间不足时，Apache RocketMQ 会按照滚动删除的方式将最早保存的消息从物理文件中删除。具体信息，请参见消息存储与清理

==========================================延迟消息==========================================
延迟消息的最大时间范围为24小时

生命周期
在普通消息的第一和第二步之间，多了一步：
定时中：消息发送到服务端，在指定投递时间之前，消息存储在基于时间的存储系统中。不会立即为消息创建索引

==========================================顺序消息==========================================
RocketMQ使用消息组来确定顺序消息的顺序。您必须为顺序消息配置【消息组】（普通消息和延迟消息则不用）。消息组中的消息按照先进先出 (FIFO) 的顺序处理。消息排序不适用于不同的消息组或不在消息组中的消息。
要实现顺序消息，主要从两方面入手：生产顺序和消费顺序

生产顺序性
RocketMQ确保消息从生产者串行发送到服务器，并按照消息的发送顺序存储和持久化。要确保消息的生产顺序，请确保满足以下条件：
1.单个生产者：消息的生产顺序适用于单个生产者。Apache RocketMQ 无法确定来自不同系统中不同生产者的消息的顺序，即使您为这些消息配置了相同的消息组
2.串行传输：Apache RocketMQ 中的生产者支持使用多线程进行安全访问。如果生产者使用多线程并发发送消息，Apache RocketMQ 无法确定来自不同线程的消息的顺序
如果满足上述条件的生产者向RocketMQ发送消息，则属于【同一消息组】的消息将按照发送顺序存储在【同一队列】中。举例：
producer1  -> messageGroup1 -> m1,m2,m3
           -> messageGroup2 -> m4,m5
producer2  -> messageGroup3 -> m6,m7
           -> messageGroup4 -> m8,m9
可能的队列及消息顺序
queue1:m7,m3,m2,m6,m1
queue2:m5,m4,m9,m8
即mq保证消息组1中的消息（m1,m2,m3）按照发送顺序在同一个队列中，但消息组1和消息组4的消息没有特定顺序

消费顺序性
要确保消息的消费顺序，请确保满足以下条件：
投递顺序：Apache RocketMQ 通过客户端 SDK 和服务器端通信协议，确保消息按照服务器上的消息存储顺序投递。当消费者应用消费消息时，应用必须遵循【接收】-【处理】-【回复】路径，以防止异步处理导致消息乱序
有限重试：Apache RocketMQ 限制顺序消息的投递重试次数。如果消息达到最大投递重试次数，Apache RocketMQ 将停止重试该消息的投递，以防止队列中其他消息持续等待投递

生产顺序性和消费顺序性组合
如果消息需要严格按照先进先出（FIFO）的原则处理，即先发送的先消费、后发送的后消费，则必须要同时满足生产顺序性和消费顺序性
一般业务场景下，同一个生产者可能对接多个下游消费者，不一定所有的消费者业务都需要顺序消费，您可以将生产顺序性和消费顺序性进行差异化组合，应用于不同的业务场景
生产顺序                            消费顺序	        顺序性效果
设置消息组，保证消息顺序发送          顺序消费        按照消息组粒度，严格保证消息顺序。 同一消息组内的消息的消费顺序和发送顺序完全一致
设置消息组，保证消息顺序发送          并发消费        并发消费，尽可能按时间顺序处理
未设置消息组，消息乱序发送           顺序消费        按队列存储粒度，严格顺序。 基于 Apache RocketMQ 本身队列的属性，消费顺序和队列存储的顺序一致，但不保证和发送顺序一致
未设置消息组，消息乱序发送           并发消费        并发消费，尽可能按照时间顺序处理

使用示例
创建topic
./bin/mqadmin updateTopic -c DefaultCluster -t FIFOTopic -o true -n 127.0.0.1:9876 -a +message.type=FIFO
注意：message.type是逻辑标记，不会影响底层机制。-o true才是决定底层机制的。发送顺序消息时，通过 Hash(Message Group)%Topic的队列总数计算出队列id，但-o false时，队列id≠物理队列
比如-o false时，消息a经计算，发送到队列0，对应broker 0，但broker 0宕机，mq触发兜底机制，自动将队列0的发送请求切换到队列1，导致乱序
如果-o true，则不会切换，重试等待broker 0恢复。即-o true本质作用是把队列id和broker绑定，队列数调整时也禁止动态扩缩容
官方文档也特别指出，不要将普通Topic用于FIFO消息，即使指定了Message Group
创建消费组
./bin/mqadmin updateSubGroup -c DefaultCluster -g FIFOGroup -n 127.0.0.1:9876 -o true
-o true的作用是保证一个队列中的消息由一个消费者线程【串行】消费。具体来说，消费者会锁定队列，消息是单条消费，提交offset后才会消费下一条
如果设置为false，可能会被多线程并行消费

使用建议
1.使用串行消费以防止消息乱序处理。我们建议您使用串行消息消费而不是批量消费。同时消费多条消息可能会导致消息乱序处理
2.避免在消息组中包含大量消息。包含大量消息的消息组会导致相应队列过载。这会影响消息传递性能并阻碍可伸缩性。我们建议您在业务应用中按消息组拆分消息。例如，您可以使用订单 ID 和用户 ID 作为消息组关键字来实现同一用户消息的有序处理

==========================================事务消息==========================================
场景：在分布式事务中，需要确保核心事务和分支事务（即下游系统的事务）的执行结果之间保持一致性。比如订单系统是核心业务，积分系统、购物车系统是下游业务
方案1：XA协议，缺点是性能差
方案2：将核心事务视为本地事务，发送普通消息通知下游系统执行分支事务
缺点是核心事务与分支事务的结果不一致：比如分支事务已执行，但核心事务未执行，因此需要回滚；比如核心事务已执行，但消息未发送（或丢失），需要重新发送

事务消息的目的是确保消息生产与本地事务之间的最终一致性。即把操作数据库和发送消息这两个行为包装为一个原子操作（非强一致）

处理流程
1.生产者向 Apache RocketMQ Broker 发送消息
2.Apache RocketMQ Broker 保存消息并将其标记为不可投递。处于此状态的消息称为半消息。之后，Broker 向生产者发送确认消息（ACK）
3.生产者执行本地事务
4.生产者向 Broker 发送第二次 ACK，以提交本地事务的执行结果。执行结果可能是 Commit（提交）或 Rollback（回滚）
如果 Broker 收到的消息状态是 Commit（提交），则 Broker 将半消息标记为可投递，并将消息投递给消费者
如果 Broker 收到的消息状态是 Rollback（回滚），则 Broker 回滚事务，并且不将半消息投递给消费者
5.如果网络断开或生产者应用程序重新启动，并且 Broker 未收到第二次 ACK 或半消息的状态为 Unknown（未知），则 Broker 会等待一段时间，然后向生产者集群中的某个生产者发送请求，查询半消息的状态
6.生产者收到请求后，会检查与半消息对应的本地事务的执行结果
7.生产者根据本地事务的执行结果向 Apache RocketMQ Broker 发送另一个 ACK。然后，Broker 按照步骤 4 处理半消息

生命周期
初始化
事务挂起：半消息被发送到 Broker。但是，它不会立即写入磁盘进行永久存储。相反，它存储在事务存储系统中。直到系统验证本地事务的第二阶段成功后，消息才会被提交。在此期间，消息对下游消费者不可见
回滚：在第二阶段，如果事务的执行结果是回滚，Broker 会回滚半消息并终止工作流程
就绪
处理中
已确认
已删除

伪代码
//生产者未及时返回二次确认时，broker通过TransactionChecker（返回枚举值COMMIT或ROLLBACK）来检查事务执行结果
producer = new Producer(new TransactionChecker);
message = messageBuilder.build();
transaction = producer.beginTransaction();
sendReceipt = producer.send(message, transaction);
localTransactionOk = doLocalTransaction();
if(localTransactionOk){
    transaction.commit();
}else{
    transaction.rollback();
}

使用限制
下游重试：下游业务必须保证消息能得到正确的处理，建议进行正确的消费重试
最终一致性：事务消息功能只保证最终一致性，这意味着在消息投递给消费者之前，上游事务和下游分支之间的状态一致性无法保证。因此，事务消息仅适用于接受异步执行的事务场景

使用建议
1.避免大量未决事务导致超时
生产者执行本地事务返回未知结果时，mq会发起事务回查。大量的事务检查会影响系统性能
2.正确处理“进行中”的事务
消息回查时，【进行中的事务】不要返回rollback或commit，而是继续保持unknow状态
出现这种状况的原因可能是事务执行太慢

==========================================消息发送重试和流控==========================================
重试
mq客户端内置了重试机制，可以设置最大重试次数，同步和异步模式都支持。重试一般是由于请求超时、网络连接失败、节点下线、服务端返回错误码（逻辑错误、流控错误）等
如果是流控导致的重试，则按照【指数退避算法】进行延迟重试；其他情况则无等待间隔，立即重试

功能约束
合理设置最大重试次数
重试仍失败后，业务方需做好保护处理
消息可能重复发送，消费者需处理好重复消息

流控
系统容量或水位过高，mq服务端快速失败返回流控错误
触发场景
1.存储压力大：某些场景需要从回溯到指定时刻开始消费，此时队列的存储压力会增大，触发限流
2.消息堆积，堆积数量超过阈值

==========================================消息者分类==========================================
RocketMQ支持PushConsumer、SimpleConsumer以及PullConsumer这三种类型的消费者

======================PushConsumer======================
一种高度封装的消费者类型，消费消息仅通过【消费监听器】（MessageListener）处理业务并返回消费结果。消息的获取、消费状态提交以及消费重试都通过mq的客户端SDK完成
消费监听器执行结果分为以下三种情况：
1.返回消费成功：以Java SDK为例，返回ConsumeResult.SUCCESS，表示该消息处理成功，服务端按照消费结果更新消费进度
2.返回消费失败：以Java SDK为例，返回ConsumeResult.FAILURE，表示该消息处理失败，需要根据消费重试逻辑判断是否进行重试消费
3.出现非预期失败：例如抛异常等行为，该结果按照消费失败处理，需要根据消费重试逻辑判断是否进行重试消费

消费超时
PushConsumer消费消息时，若消息处理逻辑出现预期之外的阻塞导致消息处理一直无法执行成功，SDK会按照消费超时处理强制提交消费失败结果，并按照消费重试逻辑进行处理
出现消费超时情况时，SDK虽然提交消费失败结果，但是当前消费线程可能仍然无法响应中断，还会继续处理消息

内部原理
消息的实时处理能力是基于SDK内部的典型Reactor线程模型实现的
SDK内置了一个长轮询线程，先将消息异步拉取到SDK内置的缓存队列中，再分别提交到消费线程中，触发监听器执行本地消费逻辑

可靠性重试
客户端SDK严格按照监听器的返回结果判断消息是否消费成功，并做可靠性重试。所有消息必须以同步方式进行消费处理，并在监听器接口结束时返回调用结果，不允许再做异步化分发
不允许使用以下方式处理消息
1.消息还未处理完成，就提前返回消费成功结果。此时如果消息消费失败，Apache RocketMQ 服务端是无法感知的，因此不会进行消费重试
2.在消费监听器内将消息再次分发到自定义的其他线程，消费监听器提前返回消费结果。此时如果消息消费失败，Apache RocketMQ 服务端同样无法感知，因此也不会进行消费重试

顺序性保障
如果消费者分组设置了顺序消费模式，则PushConsumer在触发消费监听器时，严格遵循消息的先后顺序。业务处理逻辑无感知即可保证消息的消费顺序

适用场景
PushConsumer严格限制了消息同步处理及每条消息的处理超时时间，适用于以下场景：
消息处理时间可预估：如果不确定消息处理耗时，经常有预期之外的长时间耗时的消息，PushConsumer的可靠性保证会频繁触发消息重试机制造成大量重复消息
无异步化、高级定制场景：PushConsumer限制了消费逻辑的线程模型，由客户端SDK内部按最大吞吐量触发消息处理。该模型开发逻辑简单，但是不允许使用异步化和自定义处理流程

==========================================消息过滤==========================================
消息过滤功能通过生产者和消费者对消息的属性、标签进行定义，并在 Apache RocketMQ 服务端根据过滤条件进行筛选匹配，将符合条件的消息投递给消费者进行消费

消息过滤主要通过以下几个关键流程实现：
生产者：生产者在初始化消息时预先为消息设置一些属性和标签，用于后续消费时指定过滤目标。
消费者：消费者在初始化及后续消费流程中通过调用订阅关系注册接口，向服务端上报需要订阅指定主题的哪些消息，即过滤条件。
服务端：消费者获取消息时会触发服务端的动态过滤计算，Apache RocketMQ 服务端根据消费者上报的过滤条件的表达式进行匹配，并将符合条件的消息投递给消费者。

消息过滤分类
=====================Tag标签过滤=====================
基础消息过滤能力
生产者在发送消息时，设置消息的Tag标签，消费者需指定已有的Tag标签来进行匹配订阅
Tag由生产者发送消息时设置，每条消息允许设置【一个】Tag标签。Tag使用可见字符，建议长度不超过128字符

消费者匹配标签为【精准匹配】
支持单标签、多标签（多个Tag之间为或的关系，使用两个竖线（||）隔开，例如Tag1||Tag2||Tag3）、全匹配（星号（*））

=====================SQL属性过滤=====================
高级消息过滤方式
生产者在发送消息时可设置多个属性（每个属性都是一个自定义的键值对Key-Value），消费者订阅时可设置SQL语法的过滤表达式过滤多个属性
SQL属性过滤使用SQL92语法作为过滤规则表达式，语法如：IS NULL、BETWEEN xxx AND xxx、IN (xxx, xxx)等

使用建议
合理划分主题和Tag标签
从消息的过滤机制和主题的原理机制可以看出，业务消息的拆分可以基于主题进行筛选，也可以基于主题内消息的Tag标签及属性进行筛选。关于拆分方式的选择，应遵循以下原则：
消息类型是否一致：不同类型的消息，如顺序消息和普通消息需要使用不同的主题进行拆分，无法通过Tag标签进行分类
业务域是否相同：不同业务域和部门的消息应该拆分不同的主题。例如物流消息和支付消息应该使用两个不同的主题；同样是一个主题内的物流消息，普通物流消息和加急物流消息则可以通过不同的Tag进行区分
消息量级和重要性是否一致：如果消息的量级规模存在巨大差异，或者说消息的链路重要程度存在差异，则应该使用不同的主题进行隔离拆分

==========================================消费者负载均衡==========================================
一个消费组内有多个消费者时，消息按哪种逻辑分配给哪个消费者，即为负载均衡
根据粒度，负载均衡策略可分为两种：
消息粒度：PushConsumer和SimpleConsumer默认负载策略
队列粒度：PullConsumer默认负载策略

======================消息粒度负载均衡======================
5.0 SDK PushConsumer默认使用消息粒度负载均衡，3.x和4.x仍然使用了队列粒度负载均衡
消息粒度的含义是：同一个队列中的消息，被平均地【随机】分配给多个消费者中的一个。不能指定消息被哪个消费者消费
举例：队列1中包含m1、m2、m3、m4、m5消息，有A1、A2、A3 3个消费者，则A1消费m2、m5；A2消费m1；A3消费m3、m4
消费者获取某条消息后，服务端会将该消息加锁，保证这条消息对其他消费者不可见，直到该消息消费成功或消费超时
因此，即使多个消费者同时消费同一队列的消息，服务端也可保证消息不会被多个消费者重复消费

顺序消息
所谓顺序，即保证同一消息组内的消息，按照服务端存储的先后顺序进行消费
不同消费者处理同一个消息组内的消息时，会严格按照先后顺序锁定消息状态，确保同一消息组的消息串行消费
举例：队列1的顺序消息的顺序为m1、m2、m3、m4，消费者A1消费m1、m2，A2消费m3、m4，只要A1的消费结果没有提交，A2是无法并行处理后续的消息的，必须等A1提交才行

