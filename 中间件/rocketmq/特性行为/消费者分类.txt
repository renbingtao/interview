RocketMQ支持PushConsumer、SimpleConsumer以及PullConsumer这三种类型的消费者

注意，这几个类对应的sdk都是org.apache.rocketmq:rocketmq-client-java，而非org.apache.rocketmq:rocketmq-client
前者使用的grpc协议，仅支持5.0版本服务端；后者使用remoting协议，兼容4.x、5.x版本服务端

======================PushConsumer======================
一种高度封装的消费者类型，消费消息仅通过【消费监听器】（MessageListener）处理业务并返回消费结果。消息的获取、消费状态提交以及消费重试都通过mq的客户端SDK完成
消费监听器执行结果分为以下三种情况：
1.返回消费成功：以Java SDK为例，返回ConsumeResult.SUCCESS，表示该消息处理成功，服务端按照消费结果更新消费进度
2.返回消费失败：以Java SDK为例，返回ConsumeResult.FAILURE，表示该消息处理失败，需要根据消费重试逻辑判断是否进行重试消费
3.出现非预期失败：例如抛异常等行为，该结果按照消费失败处理，需要根据消费重试逻辑判断是否进行重试消费

消费超时
PushConsumer消费消息时，若消息处理逻辑出现预期之外的阻塞导致消息处理一直无法执行成功，SDK会按照消费超时处理强制提交消费失败结果，并按照消费重试逻辑进行处理
出现消费超时情况时，SDK虽然提交消费失败结果，但是当前消费线程可能仍然无法响应中断，还会继续处理消息

内部原理
消息的实时处理能力是基于SDK内部的典型Reactor线程模型实现的
SDK内置了一个长轮询线程，先将消息异步拉取到SDK内置的缓存队列中，再分别提交到消费线程中，触发监听器执行本地消费逻辑

可靠性重试
客户端SDK严格按照监听器的返回结果判断消息是否消费成功，并做可靠性重试。所有消息必须以同步方式进行消费处理，并在监听器接口结束时返回调用结果，不允许再做异步化分发
不允许使用以下方式处理消息
1.消息还未处理完成，就提前返回消费成功结果。此时如果消息消费失败，Apache RocketMQ 服务端是无法感知的，因此不会进行消费重试
2.在消费监听器内将消息再次分发到自定义的其他线程，消费监听器提前返回消费结果。此时如果消息消费失败，Apache RocketMQ 服务端同样无法感知，因此也不会进行消费重试

顺序性保障
如果消费者分组设置了顺序消费模式，则PushConsumer在触发消费监听器时，严格遵循消息的先后顺序。业务处理逻辑无感知即可保证消息的消费顺序

适用场景
PushConsumer严格限制了消息同步处理及每条消息的处理超时时间，适用于以下场景：
消息处理时间可预估：如果不确定消息处理耗时，经常有预期之外的长时间耗时的消息，PushConsumer的可靠性保证会频繁触发消息重试机制造成大量重复消息
无异步化、高级定制场景：PushConsumer限制了消费逻辑的线程模型，由客户端SDK内部按最大吞吐量触发消息处理。该模型开发逻辑简单，但是不允许使用异步化和自定义处理流程

======================SimpleConsumer======================


