
一个消费组内有多个消费者时，消息按哪种逻辑分配给哪个消费者，即为负载均衡
根据粒度，负载均衡策略可分为两种：
消息粒度：PushConsumer和SimpleConsumer默认负载策略
队列粒度：PullConsumer默认负载策略

======================消息粒度负载均衡======================
5.0 SDK PushConsumer和SimpleConsumer默认且只能使用消息粒度负载均衡，3.x和4.x仍然使用了队列粒度负载均衡

策略原理
同一个队列中的消息，被平均地【随机】分配给多个消费者中的一个。不能指定消息被哪个消费者消费
举例：队列1中包含m1、m2、m3、m4、m5消息，有A1、A2、A3 3个消费者，则A1消费m2、m5；A2消费m1；A3消费m3、m4
消费者获取某条消息后，服务端会将该消息加锁，保证这条消息对其他消费者不可见，直到该消息消费成功或消费超时
因此，即使多个消费者同时消费同一队列的消息，服务端也可保证消息不会被多个消费者重复消费

顺序消息
所谓顺序，即保证同一消息组内的消息，按照服务端存储的先后顺序进行消费
不同消费者处理同一个消息组内的消息时，会严格按照先后顺序锁定消息状态，确保同一消息组的消息串行消费
举例：队列1的顺序消息的顺序为m1、m2、m3、m4，消费者A1消费m1、m2，A2消费m3、m4，只要A1的消费结果没有提交，A2是无法并行处理后续的消息的，必须等A1提交才行

策略特点（相比队列粒度）
1.消费分摊均匀：传统的队列粒度，要求队列数量和消费者数量相等，否则可能导致部分消费者空闲，部分消费者处理过多消息。消息粒度可以不用关注这种相对关系
2.对非对等的消费者更友好：由于网络分区延迟、硬件规格不同等原因，不同消费者的消费能力不一致。消息粒度可以按需分配
3.队列分配运维更方便：队列粒度要求队列数量>=消费者数量，而消息粒度无需关注队列数

适用场景
只需要基本的消息处理能力，对消息之间没有批量聚合的需求
对于流式处理场景、聚合计算场景，则适合队列粒度

======================队列粒度负载均衡======================
服务端4.x和3.x版本的消费者，默认且只能使用队列粒度的负载均衡策略

策略原理
每个队列仅被一个消费者消费

消费过程
取消息 -> 提交offset -> 持久化offset
取消息过程不提交消费状态。消费者数量、队列数量变化时，可能导致少量消息被重复处理

策略特点
力度大，不灵活，但天生适合流式处理、聚合处理

使用建议
无论是消息粒度还是队列粒度，消费者都要做好负载均衡
