
==========================================普通消息==========================================
适用于消息之间独立，无需关联的场景
生命周期
1.初始化（Initialized）：消息由生产者构建、初始化，准备发送到服务端
2.就绪（Ready）：消息成功发送到服务端，对消费者可见并可被消费
3.处理中（Inflight）：消息被消费者获取，根据消费者本地业务逻辑进行处理
在此过程中，服务端会等待消费者完成消费并提交消费结果。如果服务端在一定时间内未收到消费者响应，Apache RocketMQ 会对该消息进行重试
4.已确认（Acked）：消费者完成消费，并向服务端提交消费结果。服务端标记当前消息是否消费成功
Apache RocketMQ 默认保存所有消息。消费结果提交时，消息数据只是被逻辑标记为已消费，并不会立即删除。因此，消费者可以在消息因保存时间过期或存储空间不足被删除前，进行消息回溯重新消费
5.已删除（Deleted）：当消息保存时间到期或存储空间不足时，Apache RocketMQ 会按照滚动删除的方式将最早保存的消息从物理文件中删除。具体信息，请参见消息存储与清理

==========================================延迟消息==========================================
延迟消息的最大时间范围为24小时

适用场景
1.分布式定时调度
2.任务超时处理

生命周期
在普通消息的第一和第二步之间，多了一步：
定时中：消息发送到服务端，在指定投递时间之前，消息存储在基于时间的存储系统中。不会立即为消息创建索引。该消息对消费者不可见

==========================================顺序消息==========================================
RocketMQ使用消息组来确定顺序消息的顺序。您必须为顺序消息配置【消息组】（普通消息和延迟消息则不用）。消息组中的消息按照先进先出 (FIFO) 的顺序处理。消息排序不适用于不同的消息组或不在消息组中的消息。
要实现顺序消息，主要从两方面入手：生产顺序和消费顺序

生产顺序性
RocketMQ确保消息从生产者串行发送到服务器，并按照消息的发送顺序存储和持久化。要确保消息的生产顺序，请确保满足以下条件：
1.单个生产者：消息的生产顺序适用于单个生产者。Apache RocketMQ 无法确定来自不同系统中不同生产者的消息的顺序，即使您为这些消息配置了相同的消息组
2.串行传输：Apache RocketMQ 中的生产者支持使用多线程进行安全访问。如果生产者使用多线程并发发送消息，Apache RocketMQ 无法确定来自不同线程的消息的顺序
如果满足上述条件的生产者向RocketMQ发送消息，则属于【同一消息组】的消息将按照发送顺序存储在【同一队列】中。举例：
producer1  -> messageGroup1 -> m1,m2,m3
           -> messageGroup2 -> m4,m5
producer2  -> messageGroup3 -> m6,m7
           -> messageGroup4 -> m8,m9
可能的队列及消息顺序
queue1:m7,m3,m2,m6,m1
queue2:m5,m4,m9,m8
即mq保证消息组1中的消息（m1,m2,m3）按照发送顺序在同一个队列中，但消息组1和消息组4的消息没有特定顺序

消费顺序性
要确保消息的消费顺序，请确保满足以下条件：
投递顺序：Apache RocketMQ 通过客户端 SDK 和服务器端通信协议，确保消息按照服务器上的消息存储顺序投递。当消费者应用消费消息时，应用必须遵循【接收】-【处理】-【回复】路径，以防止异步处理导致消息乱序
有限重试：Apache RocketMQ 限制顺序消息的投递重试次数。如果消息达到最大投递重试次数，Apache RocketMQ 将停止重试该消息的投递，以防止队列中其他消息持续等待投递

生产顺序性和消费顺序性组合
如果消息需要严格按照先进先出（FIFO）的原则处理，即先发送的先消费、后发送的后消费，则必须要同时满足生产顺序性和消费顺序性
一般业务场景下，同一个生产者可能对接多个下游消费者，不一定所有的消费者业务都需要顺序消费，您可以将生产顺序性和消费顺序性进行差异化组合，应用于不同的业务场景
生产顺序                            消费顺序	        顺序性效果
设置消息组，保证消息顺序发送          顺序消费        按照消息组粒度，严格保证消息顺序。 同一消息组内的消息的消费顺序和发送顺序完全一致
设置消息组，保证消息顺序发送          并发消费        并发消费，尽可能按时间顺序处理
未设置消息组，消息乱序发送           顺序消费        按队列存储粒度，严格顺序。 基于 Apache RocketMQ 本身队列的属性，消费顺序和队列存储的顺序一致，但不保证和发送顺序一致
未设置消息组，消息乱序发送           并发消费        并发消费，尽可能按照时间顺序处理

使用示例
创建topic
./bin/mqadmin updateTopic -c DefaultCluster -t FIFOTopic -o true -n 127.0.0.1:9876 -a +message.type=FIFO
注意：message.type是逻辑标记，不会影响底层机制。-o true才是决定底层机制的。发送顺序消息时，通过 Hash(Message Group)%Topic的队列总数计算出队列id，但-o false时，队列id≠物理队列
比如-o false时，消息a经计算，发送到队列0，对应broker 0，但broker 0宕机，mq触发兜底机制，自动将队列0的发送请求切换到队列1，导致乱序
如果-o true，则不会切换，重试等待broker 0恢复。即-o true本质作用是把队列id和broker绑定，队列数调整时也禁止动态扩缩容
官方文档也特别指出，不要将普通Topic用于FIFO消息，即使指定了Message Group
创建消费组
./bin/mqadmin updateSubGroup -c DefaultCluster -g FIFOGroup -n 127.0.0.1:9876 -o true
-o true的作用是保证一个队列中的消息由一个消费者线程【串行】消费。具体来说，消费者会锁定队列，消息是单条消费，提交offset后才会消费下一条
如果设置为false，可能会被多线程并行消费

使用建议
1.使用串行消费以防止消息乱序处理。我们建议您使用串行消息消费而不是批量消费。同时消费多条消息可能会导致消息乱序处理
2.避免在消息组中包含大量消息。包含大量消息的消息组会导致相应队列过载。这会影响消息传递性能并阻碍可伸缩性。我们建议您在业务应用中按消息组拆分消息。例如，您可以使用订单 ID 和用户 ID 作为消息组关键字来实现同一用户消息的有序处理

==========================================事务消息==========================================
场景：在分布式事务中，需要确保核心事务和分支事务（即下游系统的事务）的执行结果之间保持一致性。比如订单系统是核心业务，积分系统、购物车系统是下游业务
方案1：XA协议，缺点是性能差
方案2：将核心事务视为本地事务，发送普通消息通知下游系统执行分支事务
缺点是核心事务与分支事务的结果不一致：比如分支事务已执行，但核心事务未执行，因此需要回滚；比如核心事务已执行，但消息未发送（或丢失），需要重新发送

事务消息的目的是确保消息生产与本地事务之间的最终一致性。即把操作数据库和发送消息这两个行为包装为一个原子操作（非强一致）

处理流程
1.生产者向 Apache RocketMQ Broker 发送消息
2.Apache RocketMQ Broker 保存消息并将其标记为不可投递。处于此状态的消息称为半消息。之后，Broker 向生产者发送确认消息（ACK）
3.生产者执行本地事务
4.生产者向 Broker 发送第二次 ACK，以提交本地事务的执行结果。执行结果可能是 Commit（提交）或 Rollback（回滚）
如果 Broker 收到的消息状态是 Commit（提交），则 Broker 将半消息标记为可投递，并将消息投递给消费者
如果 Broker 收到的消息状态是 Rollback（回滚），则 Broker 回滚事务，并且不将半消息投递给消费者
5.如果网络断开或生产者应用程序重新启动，并且 Broker 未收到第二次 ACK 或半消息的状态为 Unknown（未知），则 Broker 会等待一段时间，然后向生产者集群中的某个生产者发送请求，查询半消息的状态
6.生产者收到请求后，会检查与半消息对应的本地事务的执行结果
7.生产者根据本地事务的执行结果向 Apache RocketMQ Broker 发送另一个 ACK。然后，Broker 按照步骤 4 处理半消息

生命周期
初始化
事务挂起：半消息被发送到 Broker。但是，它不会立即写入磁盘进行永久存储。相反，它存储在事务存储系统中。直到系统验证本地事务的第二阶段成功后，消息才会被提交。在此期间，消息对下游消费者不可见
回滚：在第二阶段，如果事务的执行结果是回滚，Broker 会回滚半消息并终止工作流程
就绪
处理中
已确认
已删除

伪代码
//生产者未及时返回二次确认时，broker通过TransactionChecker（返回枚举值COMMIT或ROLLBACK）来检查事务执行结果
producer = new Producer(new TransactionChecker);
message = messageBuilder.build();
transaction = producer.beginTransaction();
sendReceipt = producer.send(message, transaction);
localTransactionOk = doLocalTransaction();
if(localTransactionOk){
    transaction.commit();
}else{
    transaction.rollback();
}

使用限制
下游重试：下游业务必须保证消息能得到正确的处理，建议进行正确的消费重试
最终一致性：事务消息功能只保证最终一致性，这意味着在消息投递给消费者之前，上游事务和下游分支之间的状态一致性无法保证。因此，事务消息仅适用于接受异步执行的事务场景

使用建议
1.避免大量未决事务导致超时
生产者执行本地事务返回未知结果时，mq会发起事务回查。大量的事务检查会影响系统性能
2.正确处理“进行中”的事务
消息回查时，【进行中的事务】不要返回rollback或commit，而是继续保持unknow状态
出现这种状况的原因可能是事务执行太慢
