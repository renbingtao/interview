=============================主题（Topic）=============================
一个主题包含一个或多个队列。消息存储和可伸缩性是基于队列实现的。主题的所有约束和属性设置都是基于主题中的队列实现的。

=============================队列（MessageQueue）=============================
消息的最小存储单元。每个topic都由多个队列组成。队列通过QueueId来做唯一标识和区分。队列提供以下优点
有序存储：队列本质上是有序的，消息以入队时的相同顺序存储。最早的消息在队列的开头，最新的消息在队列的末尾。偏移量用于标记消息在队列中的位置和顺序
流式操作语义：Apache RocketMQ 中基于队列的存储允许消费者从一个偏移量读取一条或多条消息。这有助于实现聚合读取和回溯读取等功能。这些功能在 RabbitMQ 或 ActiveMQ 中不可用

=============================消息（Message）=============================
最小数据传输单元。消息不可变，且持久化
消息内部的属性：topic名称、消息类型、消息队列、offset、消息id、索引key列表、tag、定时时间、消息发送时间（生产者的本地时间）、消息保存时间（服务端完成存储时的时间）、消费重试次数、业务自定义属性
索引key列表：消息的索引键，通过设置不同的key区分消息和快速查找消息，由生产者定义

消息类型（MessageType）
普通消息
顺序消息
事务消息
延时消息

消息标签（MessageTag）
细粒度消息分类属性，可以在主题层级之下做消息类型的细分

消息位点（MessageQueueOffset）
消息是按到达Apache RocketMQ 服务端的先后顺序存储在指定主题的多个队列中，每条消息在队列中都有一个唯一的Long类型坐标，这个坐标被定义为消息位点

消费位点（ConsumerOffset）
一条消息被某个消费者消费完成后不会立即从队列中删除，Apache RocketMQ 会基于每个消费者分组记录消费过的最新一条消息的位点，即消费位点

消息索引（MessageKey）
面向消息的索引属性。通过设置的消息索引可以快速查找到对应的消息内容

=============================生产者=============================
发送方式：同步和异步
批量发送：生产者可以设置批量发送的消息数

使用建议
生产者和topic是多对多的关系，一个生产者可以向多个topic发送消息，无需为每个topic都创建一个生产者
不建议频繁创建和销毁生产者。不需要每次发送消息时创建生产者，发送后销毁生产者

=============================订阅关系=============================
订阅关系是消费者获取消息、处理消息的规则和状态配置
由消费者组动态注册到服务端，并在后续的消息传输中按照订阅关系定义的【过滤规则】进行消息匹配和【消费进度】维护

通过配置订阅关系，可以控制以下
1.消息过滤规则
2.消费状态：订阅关系会持久化。消费者重启后，可以获取离线前的消费进度并继续消费

同一消费者分组内的消费者的消费逻辑要保持一致，否则可能导致消费异常。错误示例
//Consumer c1
Consumer c1 = ConsumerBuilder.build(groupA);
c1.subscribe(topicA,"TagA");
//Consumer c2
Consumer c2 = ConsumerBuilder.build(groupA);
c2.subscribe(topicA,"TagB");

c1和c2的tag需要保持一致
