
========================redis========================

缓存穿透
查询不存在的数据，导致请求打到db

缓存击穿
热点数据在缓存中失效，所有请求瞬间打到db。可以加入互斥锁，缓存失效时上锁，查db，写缓存，释放锁；其他线程请求时sleep一会

缓存雪崩
缓存集中在一段时间失效

数据类型及原理
均采用 “上层抽象类型 + 底层多数据结构自适应” 的模式。以6.0为例
String：SDS；额外分配free空间（一倍，最多1MB）；保留\0结尾，可直接复用部分C字符串函数

List：始终使用 quicklist（早期版本用 ziplist+linkedlist），由ziplist组成的双向链表（链表的每个节点都是ziplist）。插入时，找到合适的节点（头或尾），如果节点满了则新建
zipList：连续的内存空间，类似数组，由头尾节点。查询中间的元素时只能遍历O(n)。单个list过大会导致查询效率变低

Hash：zipList（key和value都<64k且size<512）-> dict
dicj：数组+链表。扩容时采用渐进式hash

Set：intset（元素都是整数且size<512） -> dict

Sorted Set：每个元素关联一个分数（score），支持按分数排序、按分数范围查询。ziplist（value和分数<64k且size<128） -> skipList+dict
skipList：效率和红黑树/平衡树接近，但实现简单。跳跃表为一个链表，每个元素为跳跃表节点，包含：后退指针、分值（用来排序）、保存的值、数组类型的层（元素包含：前进指针、跨度）。层高为1-32之间随机

Bitmap：SDS

HyperLogLog：用于统计大量数据的去重值（UV）。插入、查询时间复杂度O（1），内存使用率极低（上亿数据仅需12k），估计值但误差小（标准情况下为0.81%）

RDB
RDB生成的文件是压缩的二进制文件。有两个redis命令会生成rdb：save和bgsave。save会阻塞redis服务进程直到rdb文件创建完毕；bgsave会创建一个子进程，由子进程创建rdb
redis没有专门的命令加载rdb，而是在redis启动时检测是否存在rdb文件，存在则自动载入。但如果开启了aof，则优先使用aof文件；aof关闭时才使用rdb
生成rdb期间，是可以修改数据的，而子进程是看不到修改的数据的，因为rdb采用copy on write技术，类似快照

AOF
服务器执行的写命令会保存到AOF文件中
服务器的写命令会追加到aof_buf缓冲区中，服务器会根据策略（每次，每秒-默认，由系统决定）将缓冲区的内容写入AOF文件中
AOF文件过大时会重写，这里的重写不需要读取旧的aof文件，而是直接从数据库读取键值对，然后以redis命令的形式保存。与rdb类似，aof重写也是由子进程完成（bgrewriteaof）
在重写期间，写命令会继续执行，为了保存这部分增量数据，redis提供了aof重写缓冲区（在子进程fork后使用），在AOF重写完成后，AOF重写缓冲区的内容会写入新的AOF文件中，然后替换旧的AOF文件

事件
redis服务器是事件驱动程序，处理文件事件和时间事件
文件事件
redis基于reactor模式开发了文件事件处理器，使用IO多路复用程序监听多个套接字。6.0以前的redis的IO多路复用模型是单线程的；6.0及以后使用了多线程来处理网络IO
时间事件
redis使用周期性事件，将所有时间事件放在一个无序链表中（元素包含id，表示到期时间的when属性，无序指不按照when排序，链表本身是按照id排序的），时间事件执行器运行时遍历整个链表，找到到期的事件并执行
serverCron函数默认每秒运行10次，内容包括：更新各种统计信息；清理过期的键值对；尝试AOF或RDB操作；主服务器对从服务器定期同步；（集群模式）对集群进行定期同步和链接测试

reactor模式
基于事件驱动的设计模式，将事件的监听和处理分离，在网络编程领域应用广泛。有一个或多个reactor对象监听事件源（比如网络链接），有事件发生时，reactor将事件分发给对应的处理器
组成部分：reactor，核心，负责监听事件源，一般使用操作系统提供的IO多路复用机制（如select，poll，epoll）来监听多个事件源。event handler：处理不同类型的事件。事件多路分解器，通常是操作系统提供的IO多路复用函数
工作流程：创建reactor和事件处理器，将处理器注册到reactor，reactor调用事件多路分解器，开始循环监听事件，事件发生时，事件多路分解器将事件返回给reactor，reactor根据事件的类型，分发给不同的事件处理器

IO多路复用函数
select：每当进程打开一个文件或创建一个套接字时，内核会为其分配一个fd，fd表是线程独立的，单个进程可监控的文件描述符fd数量是有上限的（大多数系统默认是1024）
缺点：对套接字扫描是轮询的，即不管套接字是否活跃都遍历一遍；此外每次调用select时都需要传一个fd_set集合（因为select函数本身会修改传入的fd_set集合，将未发生变化的fd对应的位清除），用户空间和内核空间在传递该集合时复制开销比较大

poll：本质上和select没有区别，但是没有最大连接数的限制，因为采用了数组；另外不需要每次调用时都传该数组，数组元素叫pollfd，结构为fd+events，即要监听的事件+revents，即发生的事件，由操作系统填充。poll函数不会修改event，只会修改revent，因此开销更小

epoll：linux独有的机制，有LT（水平触发，默认）和ET（边缘触发）两种模式。epoll使用一个fd（epoll fd）来管理其他fd（event fd）。在epoll fd上注册了关注的事件，当这种事件发生时，epoll会通知程序。epoll是基于事件驱动的模型，避免了无效的轮询。epoll内部使用了红黑树来管理注册的事件，因此查询复杂度为O(log n)。水平触发：只要这个fd还有数据可读，每次epoll_wait函数（作用是等待fd上事件发生）都会触发，提醒程序处理；边缘触发：只会提示一次，直到下次有数据流入之前都不会再提示，无论fd中是否还有数据可读，因此使用ET一定要把缓存读光

主从复制
2.8版本开始，redis使用psync命令来执行同步（之前版本使用sync命令），该命令有全量和增量两种模式
全量
适用于初次复制，主服务器执行bgsave，将生成的rdb文件发送给从服务器，后续持续将缓冲区里的命令发送给从服务器（也叫命令传播），这部分的原理和sync一致，sync不支持增量同步，即重连后要重新生成rdb
增量
适用于断线后重新复制，从服务器会接收断线期期间的命令并执行。具体实现如下：
复制偏移量
主从服务器会各自维护复制偏移量，主向从发送N个字节数据，主的复制偏移量就会加N，同理，从接收N个字节后也会加N，以此来判断主从是否一致
复制积压缓冲区
主服务器维护的固定长度的队列（默认1MB），主向从发送命令时，这个命令也会写入缓冲区，且每个字节对应的偏移量也有维护，比如10087->'r'。从服务器重连后，将自己的偏移量发送给主，若偏移量之后的数据（即offset+1）仍存在于缓冲区，则增量同步，否则全量同步
运行id
redis服务器内部维护一个运行id（无论主从都会维护），全量同步时，从会记录下主的id，重连时通过比较id即可判断是否可以继续尝试增量同步
命令传播阶段
从默认以一秒一次的频率和主进行心跳检测（命令内容为REPLCONF ACK offset），该命令还可以用来检测传播的命令是否有丢失
缺点：主挂了，从不会自动切换为主，需要人工干预

哨兵模式
redis的高可用方案，由一或多个哨兵组成哨兵集群，监听多个主服务器及他们的从服务器，当主下线时，自动将从升级为主
哨兵向主发送INFO命令来获取从的信息（包括ip端口），默认以10秒1次的频率向主、从发送INFO
哨兵会和被监视的主服务器创建两个异步网络接口：命令连接和订阅连接
命令连接
向主服务器发送命令并接收回复，可以获取主的运行信息及从的信息
订阅连接
专门用于订阅主服务器的hello频道，用来发现其他哨兵，默认2秒发送一次。比如ABC三个哨兵监听同一个服务器，A向hello发送一条信息，则BC（以及A自己）都能收到这条信息，BC就可以根据信息更新状态（A自己则会舍弃）。新哨兵加入时，新哨兵内部会创建数据结构，旧哨兵也会和新哨兵互相创建命令连接（但不会创建订阅连接）
观测下线
哨兵内部有主观下线、客观下线两个标识，哨兵默认以1秒1次的频率向主、从、其他哨兵发送ping命令检测是否在线，在响应超时或返回非预期的回复时，会更新主观下线标识，并向其他哨兵询问，通过配置文件来判断是否需要更新客观下线标识（比如配置了2，则包含当前哨兵在内，有至少2个哨兵认为服务器已下线，才更新客观下线标识）。不同哨兵的配置文件可能是不同的
选举头领
采用raft算法。当一个主服务器被判断为客观下线时，每个认为其客观下线的哨兵会参与选举，选举出一个领头哨兵，由其进行故障转移
每隔一定时间进行一次选举，所有认为服务器客观下线的哨兵都会参与选举，在一次选举中，所有哨兵都会要求其他哨兵将自己选举为头领，所有哨兵都有一次机会将自己以外的哨兵选举为头领，采用先到先得的规则，只有获得超过半数选票的哨兵才能成为头领（刚好半数的不会）若选举不出来，则一段时间后再次选举，直到选举出来
故障转移
领头哨兵从下线的主的所有从服务器中挑一个，升级为主，其他从都会复制新的主，旧的主上线时成为从
如何选举新的主
遍历所有的从，将下列剔除：下线的、无法通信的（5秒内没有回复领头哨兵的INFO命令）、与下线的主断开时间超过预设值的（保证数据不会太旧），然后选择优先级最高的从，若优先级相同，则选偏移量最大的（也就是说数据最新），若偏移量也相同，则选运行id最小的（运行id是随机生成的）

集群模式
分布式解决方案，通过分片（sharding）进行数据共享
一个节点是一个运行在集群模式下的redis服务器，节点内部保存了集群的数据结构，包括集群里其他节点的信息（名字，ip，端口等）
集群的整个数据库被分为16384（=2048*8）个槽（slot），数据库的每个key都属于槽中的一个，每个节点可以处理0-16384个槽。当这些槽都有节点在处理时，集群处于上线（ok）状态；任意一个槽没有得到处理，则处于下线（fail）状态
节点内部使用长度为16384的二进制数组来保存当前节点处理哪些槽，0代表不处理，1代表处理，一种bitmap的思想
每个节点不光维护了自己的槽，还维护了其他节点的槽，这样每个节点都知道某个槽应该由哪个节点处理
redis的集群状态数据结构（clusterState） 中还维护了每个槽指派给哪个节点的信息，即长度为16384的数据，元素为指针，指向集群节点（clusterNode），这样O(1)的时间复杂度就可以知道某个槽由哪个节点处理
计算key属于哪个槽：CRC16(key)&16383，即通过CRC16算法计算哈希值后，对16383取模
重新分片
可以将任意数量的槽由源节点改为目标节点，该操作可以在线进行，即集群不需要下线，源和目标节点可以继续处理请求
复制
集群中的节点分为主节点（处理槽）和从节点（复制主节点，主下线时成为主，选举方式和哨兵模式中选举头领类似。原主上线时变为从）

事务
redis通过MULTI,EXEC等实现事务功能，一次将多个命令打包，一次性、顺序地执行，且执行期间不会执行其他请求，执行完毕才会处理其他请求

ACID
redis不支持回滚，事务中的某个指令出错，后续的指令也会继续执行

Lua脚本
redis在服务器中嵌入lua环境，使得客户端可以使用lua脚本，在服务端原子地执行多个redis命令

redis服务器创建并修改lua环境的过程
创建一个基础的lua环境，调用lua_open
载入多个函数库，如base library，table library，string library，math library等
创建全局table redis，其中包含对redis操作的函数，比如call，pcall
使用自制的随机函数替换lua原本的函数
创建排序辅助函数，使用该函数对部分redis命令的结果排序，消除不确定性
将修改后的lua环境保存到服务器中，等待执行客户端的lua脚本

redLock
目标是解决单点故障。获取锁时，向全部N个节点都执行set nx px命令，若超过半数（不能是等于半数）的节点都执行成功则获取锁成功
缺点：部署运维复杂，性能差，强一致场景更适合zk实现

分布式锁
1.set key value nx px 10  其中key为分布式锁的标识，value为客户端标识（比如ip或uuid）
2.执行业务代码
3.lua脚本：if get key == 客户端标识 then del key
Redisson提供了开箱即用的分布式锁，支持自动续期。调用tryLock()或lock()时，如果没有指定过期时间，redisson会启动后台线程，默认以过期时间的1/3为间隔来续期。如果指定了过期时间，则不会启动续期
自动续期是基于看门狗watchDog实现的。看门狗会每隔10秒检查锁的状态，如果仍然被当前线程持有，则通过expire 30重置过期时间
redisson的定时任务（10秒一次）是基于netty的时间轮实现的（netty又是基于jvm实现的），所以如果java进程重启，则不会续期
延展：netty的时间轮是如何实现的？
时间轮会定义一个时间轮盘，划分出多个槽位，每个槽代表一个时间段，比如秒、分钟。比如一个数组，长度60，每个元素代表1秒，则最多可表示1分钟内的定时任务
如果要表示超过1分钟的定时任务，可以再增加一个round标识。举例某任务200s后执行，则round=200/60=3，并把它放到20这个槽位上，时间轮每过一轮，round-1，round=0时才执行。但这种方案还是会遍历槽位上的所有任务，判断round，效率低
分层时间轮：定义多个时间轮，比如秒级的，分钟级的，小时级的。200s的任务放在分钟级，分钟数到了时，取出任务放到秒级时间轮

