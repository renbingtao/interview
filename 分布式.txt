
========================架构的演化历史========================

单体
ALL IN ONE，所有功能模块都在一个应用里，只有一个节点，申请公网域名，域名绑定单一节点的ip
优点：开发部署简单
缺点：无法应对高并发

集群
对单个节点复制，多个节点共同工作。由于域名只能指向一个节点，其他副本无法接受请求，因此引入了网关，网关是所有请求的入口，一般为服务器，里面部署了ng。域名绑定了网关的ip，网关把请求转发（路由）到副本，为了防止请求全都转发给同一台服务器，引入了负载均衡。当并发过大，可以通过增加副本的数量的方式（扩容）来提高应用的性能
优点：集群可以解决大并发的问题
缺点：模块升级时，整个系统都需要重新部署，牵一发而动全身

分布式
按照模块，将整个应用拆分为多个小应用（微服务），同理数据库也可拆分，每个微服务对应有自己的数据库（分库），服务之间通过接口而非数据库直连，每个微服务可以用不同的语言开发（自治）。服务之间调用时，不能写死ip，因此需要服务注册中心将服务与ip列表绑定。此外注册中心还可以管理配置，传统模式下更新了配置需要重新发布部署，有了配置中心后只需要在配置中心统一修改，配置中心会把配置的变动主动推送到微服务。当某个底层服务异常，所有依赖这个服务的上层服务也会出现响应慢，不可用，因此需要服务熔断机制，将异常的服务快速失败（通过配置，比如5秒内50%的请求都卡顿，则后5秒内的请求都失败）。由于任意节点都无法提供完整的服务，因此需要一个网关，根据请求路径从注册中心找到对应的服务，然后路由。由于数据库分库，因此需要实现分布式事务

========================对CAP的理解========================

正常情况下，一个集群内的节点之间是可以正常通信的，异常时某些节点之间无法通信，可能导致无法获取需要的数据，这是无法容忍的，因此把节点多复制几份，一个节点无法访问，但可以访问其他节点的，这就是分区容错性
然而要保证多个节点之间数据是相同的，这就带来了一致性问题，要保证一致性，写数据时要保证所有节点都写成功
保证一致性又会带来可用性问题，因为操作时间变长了。
总之，节点越多，分区容错性越高；分区容错高了，一致性又难保证；一致性保证了，可用性又难保证

分布式幂等性如何设计
查询和删除不在讨论范围之内
1.建立唯一索引
2.token机制。进入下单页前端请求后台，获取token，后台将token放入redis并设置ttl。用户下单时带上token，后台校验token是否有效，有效时更新redis的状态为处理中，然后执行业务代码，这样当用户误点击导致重复提交时，后台校验redis发现状态为处理中，则返回请勿重复提交

限流算法
计数器算法（固定窗口）：使用计数器在周期内累加，达到限流值时丢弃，下一周期开始时清零
滑动窗口：将周期分为多个小周期，分别记录每个小周期内的次数，并根据时间删除小周期
漏桶：一个底部有洞的桶，请求像水一样注入到桶中，以恒定的速率流出桶，桶满时丢弃，一般用队列实现
令牌桶：以固定的速度向令牌桶中扔令牌，直到桶满；请求需要先获取令牌才能继续，否则被丢弃

========================共识算法========================

定义
分布式系统中节点如何达成一致性的算法。常见算法为Paxos和Raft

相关背景
复制状态机：核心理念是相同的初始状态+相同的输入=相同的结果状态。通过共识算法，可以实现复制状态机（多个节点从相同的初始状态开始，顺序执行相同的命令，得到相同的结果）

Raft比较简单，多个产品都实现。raft把共识问题分解为：领导者选举、日志复制、安全性。节点之间使用RPC通信，RPC主要包括两种：投票和复制日志

任期
任意节点在leader故障后都有可能成为候选人，因此每个节点都需要知道现在的任期（任意长度的时间，用递增的数字来表示）。Raft是强领导模型，即领导者在时，才能对外提供服务，因此选举期间不能提供服务

日志
由索引、任期、指令组成。索引是严格地增大的。示例
Index       1       2       3       4       5
Term        1       1       1       2       3
Command     x <- 3  y <- 1  y <- 9  x <- 2  x <- 0

候选人
在任意时刻，每个节点都是leader、follower、candidate三种状态之一。每个节点刚启动时都是follower，follower需要每隔一段时间接收leader心跳信息或者候选人投票请求，若能收到，则继续当follower；若收不到，则认为当前集群里没有leader，发起选举，变成候选人（candidate），并把自己的任期+1，并给自己投一票，并给其他节点发出投票请求，然后在一段时间内等待投票结果。投票结果有三种：1.候选人得到超过半数票数，成为leader，通知其他节点 2.同任期内已经有其他leader或者有更高任期的leader，退回为follower 3.选举等待超时，候选人即无法成为leader，也没有接收到其他leader的通知，会开启下一轮选举：任期+1，票数重置为1，向其他节点发送投票请求

leader
定期向其他follower发送心跳，防止选举

投票
任期高的不投给任期低的；日志索引高的不投给日志索引低的节点。这是为了保证只有日志最完整的节点可以成为leader
满足上述条件后，优先投给最先发起投票请求的候选人
每个节点在一个任期内，只能投一次票

脑裂
节点间网络不通（分区故障）时，集群会分裂成多个小集群，有多个领导。当分区恢复时，任期低的leader会成为任期高leader的follower，保证只有一个leader

日志复制

========================nacos========================

注册中心
引入依赖：spring-cloud-starter-alibaba-nacos-discovery
具体配置：spring.application.name为服务名；spring.cloud.nacos.server-addr为nacos的ip端口
springboot启动后，微服务自动注册到nacos

服务发现的具体实现：启动类添加@EnableDiscoveryClient注解
在要调用的类中注入DiscoveryClient（spring提供）或NacosServiceDiscovery（nacos提供），调用getInstance方法获取所有实例，手动选择一个，然后使用new RestTemplate().getForObject(xx)进行调用
或者注入LoadBalancerClient，调用choose负载均衡地获取一个实例
或者注入RestTemplate（推荐），并加上@LoadBalanced注解，并把ip+端口改成服务名
但无论哪种，都只能获取ip及端口。路径/请求体需要手动组装

nacos宕机，还能进行远程调用吗
本地有缓存，因此如果是第一次调用，会失败；不是第一次调用则能调用


配置中心
引入依赖：spring-cloud-starter-alibaba-nacos-config
具体配置：在上面的基础上，加入spring.config.import=nacos:xxxx.properties （不需要手动新建该配置文件），多个nacos用逗号分隔
在nacos的配置中心中，手动创建一个配置（数据集），其DataID为xxxx.properties，kv自己添加
在使用配置的类上，添加@RefreshScope，才能自动刷新
在开发中，就像该配置文件存在一样，正常使用@Value注入。相当于原先本地的配置文件现在放在了nacos

上面是基本用法。可以把xxxx.properties映射到一个类，加上@Data,@Component,@ConfigurationProperties注解，无需@RefreshScope即可自动刷新（前提是配置绑定nacos）再在使用的地方注入该类
@ConfigurationProperties注解的作用是，将properties的key和类的属性一一对应，其中a-bc对应到aBc，即驼峰

监听配置变化
NacosConfigManager.getConfigService().addListener() 在listener中重写receiveConfigInfo方法，可以获取更新后的配置值

数据隔离
nacos中有多个概念。namespace（区分不同环境，dev/sit）->group（区分不同服务，order/product）->data id（区分不同数据集，common.properties/db.properties）
在配置文件中，设置spring.cloud.nacos.config.namespace=dev来指定命名空间；通过xxx.properties?group=order来指定group

nacos数据集和本地的配置文件有相同的配置项，哪个生效
数据集生效。站在设计的角度，如果本地配置文件生效，则nacos更新配置，应用内也不会更新，则nacos失去了意义。如果有多个nacos，则先声明的（前面的）优先

nacos是强一致性还是最终一致性


========================open feign========================

定义
声明式REST客户端。REST客户端指的是通过http进行远程调用。之前用到的RestTemplate是编程式REST客户端，即需要自己手动拼接ip端口路径等。声明式则只需要简单的注解，告诉open feign远程的地址，请求方式，携带的数据，返回的结果等

具体配置
启动类添加@EnableFeignClient注解
新建接口，添加@FeignClient(value = "nacos服务名")注解；定义方法，添加@PostMapping("/路径")注解。如果是第三方api调用，则可以在FeignClient注解中指定url

配置超时
针对某个feignClient：spring.cloud.openfeign.client.config.nacos服务名.connect-timeout: 3000（连接超时） 类似的还有读超时read-timeout；针对全部 feignClient，把nacos服务名改为default即可

重试
feign默认不进行重试。可以定义一个Bean Retryer(period,duration,maxAttempt)来进行重试（由spring管理），feign会自动检测（无需配置）。以（100,1000,5）为例，失败后等待100ms重试，再次失败等待150ms后重试，再失败225ms后重试，即每次*1.5，但不超过1000ms

fallback
当feign调用失败时，返回预先定义好的兜底数据，需要先引入sentinel
在FeignClient修饰的接口新增一个fallback实现类（由spring管理），实现异常时的返回，在@FeignClient(fallback=xxx.class)中指定实现类

客户端负载均衡和服务端负载均衡
客户端：A调B，A先去注册中心获取全部地址，自己根据负载均衡算法选择一个地址调用
服务端：A调B，B提供的是网关地址，网关从注册中心获取全部地址，根据算法选择一个地址进行转发

========================sentinel========================

作用是服务保护，包括限流及熔断降级
核心概念是资源和规则，按照一定的规则对资源进行保护。访问资源时，sentinel检查对应的规则，没有违反规则就放行；违反规则就抛异常，然后进行兜底处理（比如feign的fallback），若没有兜底处理，则返回默认错误
何为资源：万物皆可资源，比如web接口，方法等。sentinel与主流框架（servlet、dubbo、spring cloud等）做了自动适配，所有web接口都是资源。也可以通过编程(SphU API)或声明(@SentinelResource)的方式自定义资源
何为规则：包括流量控制、熔断降级、系统保护（根据cpu、内存使用率限制请求）、来源控制访问（只允许白名单里的上游访问资源）、热点参数

具体配置
sentinel服务启动（从官网下载jar包，java -jar启动），通过8080端口访问管理台
配置spring.cloud.sentinel.transport.dashboard: sentinel服务器ip:sentinel服务器port

资源声明
A->B，A是controller，B是serviceImpl，在B的方法上加上@SentinelResource(value="资源名")，即可把方法声明为资源，在管理台配置规则；此外可以看到调用资源的链路，该链路中包含A和B
