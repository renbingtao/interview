Autowired和Resource注解的区别
两者都是用来做bean的注入
Autowired默认按类型注入，若有多个类型则根据名称查找（也可以手动指定名称@Qualifier）
Resource不是spring的注解，spring只是支持。默认按照名称（加了注解的变量的名称）注入，名称找不到时按类型注入

@Component和@Bean的区别
@Component      写在类上                                一般用在自己写的类上                           无法控制创建过程
@Bean           写在方法上，一般和@Configuration配合      一般用在第三方库中的类（因为无法修改源代码       可以在方法中new对象，控制创建过程
总结：@Component适合简单、自己写的类，而@Bean适合需要更多控制的场景

BeanFactory和FactoryBean的区别
BeanFactory是工厂，是spring核心的bean接口，定义了管理bean的方法，比如getBean
FactoryBean是bean，是一个需要实现getObject方法的接口，作用是自定义bean的创建过程，适用于创建复杂bean的场景。如MyBatis中的SqlSessionFactoryBean就是FactoryBean的典型实现，返回SqlSessionFactory
BeanFactory.get("MyFactoryBean")返回的是MyFactoryBean的getObject返回的对象，如果要返回MyFactoryBean本身，则需要调用BeanFactory.get("&MyFactoryBean")

ApplicationContext和BeanFactory的区别
两者都是用于管理bean，BeanFactory是最基础的bean接口，定义了管理bean的方法，比如getBean。ApplicationContext继承了BeanFactory，实现了更多接口以提供更多功能，如MessageSource（国际化），ResourceLoader（资源加载），ApplicationEventPublisher（事件发布）

bean的创建顺序如何控制
比如A依赖B，但如果A先加载，B后加载，则有问题
方案1.可以在A类的注解上添加@DependsOn("serviceB")。其中serviceB为B类的驼峰名
方案2.实现BeanDefinitionRegistryPostProcessor接口，该接口会在所有的bean定义都注册后执行，我们可以手动注册新的bean定义、修改属性、控制bean定义的执行顺序。该方式更加灵活
//手动控制顺序
BeanDefinitionBuilder serviceB = BeanDefinitionBuilder.genericBeanDefinition(ServiceB.class);
registry.registerBeanDefinition("serviceB", serviceB.getBeanDefinition());
BeanDefinitionBuilder serviceA = BeanDefinitionBuilder.genericBeanDefinition(ServiceA.class);
registry.registerBeanDefinition("serviceA", serviceA.getBeanDefinition());

依赖注入的几种方式
比如有一个类A，有属性B，并提供了有参构造器
1.构造器注入，即在A的有参构造器上添加@Autowired注解，spring官方推荐的方式。特定是B为final时也可注入；A初始化初始化完成后即可使用；可检测循环依赖
2.setter注入，即在setB方法上加注解。特定是B为final时无法注入；A初始化完成后B未注入，不能直接使用；可检测循环依赖
3.属性注入，也是最常用的注入，直接在B上加注解。特点和上面一样

MVC的工作流程
1.用户发送请求至DispatcherServlet类，调用doService方法，doService又会调用doDispatch方法，下面的流程都在doDispatch内
2.检查请求是否为文件上传请求，若是则解析为multipartRequest
3.获得HandlerExecutionChain，即mappedHandler，内部包含handler，多个interceptor。DispatcherServlet内有一个List<HandlerMapping>，HandlerMapping有方法getHandler，遍历集合返回第一个非空的handler。是根据url查找的
4.获取HandlerAdapter，即ha。DispatcherServlet内有一个List<HandlerAdapter>，遍历集合，检查HandlerAdapter能否支持handler，返回第一个能支持的
5.HandlerExecutionChain执行applyPreHandle，即调用handle前先执行预方法，主要是调用拦截器
6.HandlerAdapter执行handle方法（由处理器即controller执行），返回ModelAndView。若加了@ResponseBody注解，则在handle方法中将结果以json格式写入response中，同时返回的mvc为null
7.HandlerExecutionChain执行applyPostHandle，即调用handle后再执行方法，同样是拦截器
8.检查上述过程是否有异常，有异常则将异常转换为mvc
9.若ModelAndView不为null，则解析为view。DispatcherServlet内有一个List<ViewResolver>，实现了resolveViewName方法（返回view），遍历并解析，返回第一个能解析成功的view
10.对view渲染（render），将model转换为response
11.返回response
总结：DispatcherServlet是整个流程的控制中心。HandlerMapping通过拓展实现了不同的映射方式

MVC常用的注解及作用
@RestController：Controller和ResponseBody的组合，默认返回json而不是视图
@ResponseBody：将方法的返回值作为http的body返回，而不是解析为视图名称

aop的核心概念
连接点：可以理解为现有的业务代码。比如我想在A接口的doService前打log，则AImpl的doService方法就是连接点
切面：和aop相关的方法、定义都放在一个类里，在类上加@Aspect注解，这个类就叫切面，如果某天不需要aop了，直接删除这个类就好了
切点：在切面中定义一个方法，加上@Pointcut注解，表达式为execution(* com.example.service.A.doService(..))，即筛选连接点
通知：切面在特定连接点上执行的方法，包括前置通知，后置通知等
核心关注点：与业务逻辑直接相关的主要功能，比如登录、下单
横切关注点：与业务逻辑没有直接关联，但在整个系统中广泛存在，且需要统一处理，比如日志打印。aop的目的就是把横切关注点从核心关注点中分离出来

对AOP的理解
spring aop是基于动态代理的，若被代理对象实现了接口，则使用jdk动态代理；否则使用cglib。若没有配置aop，则普通的bean（比如常见的Controller）为非代理对象

jdk代理
要求被代理对象实现了接口，基于反射实现，采用组合的方式，无法代理静态方法，运行时动态创建代理对象，性能低
需要实现InvocationHandler类并重写invoke方法，增强的逻辑都在invoke中实现。创建代理类时的参数：被代理类的classloader，接口，InvocationHandler对象。在调用代理类时，实际会调用InvocationHandler的invoke方法
若被代理类A方法内部调用B方法，则通过invoke调用A时，实际是被代理类执行A方法，不是代理类执行B方法，因此B的增强方法不会执行。总结：jdk代理类自调用时不会走增强方法

cglib代理
修改被代理类的字节码生成子类，性能高，无法对final、private方法代理。子类对象有一个MethodInterceptor对象，增强的逻辑都在这里实现，为空时执行父类方法；不为空时执行MethodInterceptor的方法
cglib继承了父类，但只是为了增强public方法，内部持有被代理对象的引用，调用proxy的方法时，最后还是由target执行，因此表面是继承，本质是组合。由于final方法无法被继承，因此调用proxy的final方法时，会调用父类方法而非由target执行，因此会出现各种异常

spring aop和aspectj aop的区别
spring是运行时增强，基于代理；aspectj是编译时增强，基于字节码操作

spring aop失效的场景
1.对private、protected方法增强
2.自调用

spring bean的生命周期
loadBeanDefinitions：
    读取配置文件（xml，注解等）解析bean definition并注册到BeanDefinitionRegistry
createBean：
    createBeanInstance：通过反射通过反射创建bean对象。单例bean在spring启动时就实例化，原型在请求获取bean时才实例化
    populateBean：通过三级缓存填充属性，即根据name或type，通过构造器、set方法、属性等方式注入bean依赖的其他bean。
    initializeBean：
        检测bean是否实现了XXXAware接口
            BeanNameAware接口，则调用setBeanName方法。这个方法不是让开发人员设置bean的name，只是用来获取name，而之所以叫做setXX，是站在spring框架而非开发的角度，为没有name的bean设置name
            BeanFactoryAware同理，调用setBeanFactory
            ApplicationContextAware同理，调用setApplicationContext
        执行BeanPostProcessor的前置方法。BeanPostProcessor是spring提供的一个拓展接口
        若bean实现了InitializingBean接口，调用afterPropertiesSet，用于属性设置完成后做一些操作
        执行自定义的初始化方法：比如@PostConstruct（这不是spring的注解，spring只是支持）或@Bean中指定了init-method方法
        BeanPostProcessor的后置方法，在这一步会检测bean对象是否使用了aop，若使用了则创建代理对象并返回
    registerDisposableBean：注册销毁时执行的方法
destroy：
    若实现了DisposableBean，则调用destroy方法
    执行自定义的销毁方法：@PreDestroy或@Bean指定了destroy-method

spring bean的作用域
单例，默认；原型，为每个请求创建一个实例；request，为每个网路请求创建一个实例；session，保证每个session中有一个实例；global-session

单例bean是线程安全的吗
spring本身没有对单例bean做任何多线程的封装处理，线程安全问题是开发人员要考虑的，spring不关心

spring三级缓存
一级：private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
缓存已经初始化好的单例bean。当获取bean时，从该缓存中查找，存在则返回。key是bean的名称

二级：private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);
存储早期暴露的单例bean。当bean实例化完成但未属性填充及初始化时，spring将单例bean放入该缓存中，主要是为了解决循环依赖

三级：private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
存储单例bean的工厂对象。通过ObjectFactory可以获取早期单例bean对象，主要是为了解决AOP代理创建等问题，提供了延迟生成bean的机制

spring如何解决循环依赖
假设AB存在循环依赖
spring实例化A，并把A的工厂对象放入三级缓存中
填充A的属性，发现A依赖B，于是创建B
实例化B，同样把B的工厂对象加入三级缓存
填充B属性，发现B依赖A，从一级缓存找A，不存在；从二级缓存中查找A，不存在；则在三级缓存中查找，能找到，将A从三级缓存中移除，放到二级缓存
将早期的A注入到B的属性中，完成B的属性填充及初始化，放入一级缓存
将B注入A的属性中，完成A的属性填充及初始化，放入一级缓存（初始化完成后才放入一级缓存）

第三级缓存的作用
如果只是为了解决循环依赖，二级缓存就够了，第三级缓存是为了考虑到AOP
正常没有循环依赖时，bean初始化完成后创建代理对象，然后把一级缓存中的被代理对象替换成代理对象
有循环依赖时，代理对象的创建会提前放到早期暴漏阶段（即第二级缓存）
仍然以上面为例，A的工厂对象放入三级缓存中，创建B时，需要注入A
1.若不提前放到早期暴漏阶段，从三级缓存获取A的工厂对象，工厂返回的是A的原始对象，即B.A为原始对象。后续A完成初始化被替换为代理对象，导致和B.A不一致
2.若提前放到早期暴漏阶段，从工厂对象中获取A，即调用ObjectFactory.getObject()时，会检查是否需要创建代理对象，若需要则在此阶段创建代理对象，并将代理对象放入二级缓存，即B.A为代理对象。A的后续创建都使用代理对象，A和B.A一致

理论上，在实例化阶段检查是否需要代理，也可以只需要二级缓存，但会违反单一职责的思想 --> 实例化应只做实例化应做的事，不应考虑代理的事

spring使用了哪些设计模式
简单工厂模式：BeanFactory
工厂方法模式：FactoryBean
代理模式：AOP
观察者模式：各种Event和Listener
责任链模式：spring拦截器

优雅关闭
底层依赖shutdown hook，是触发点
触发后，执行bean的destroy方法、@PreDestroy

如何在spring运行期间动态生成bean
已定义DynamicService这个类，包含name和description两个属性。
方式1：通过BeanDefinitionRegistry注册Bean
BeanDefinition beanDefinition = BeanDefinitionBuilder
                .genericBeanDefinition(DynamicService.class)
                .addPropertyValue("name", name)
                .addPropertyValue("description", description)
                .setScope("singleton") // 单例模式
                .getBeanDefinition();
ConfigurableApplicationContext configurableContext = (ConfigurableApplicationContext) context;
BeanDefinitionRegistry registry = (BeanDefinitionRegistry) configurableContext.getBeanFactory();
registry.registerBeanDefinition(beanName, beanDefinition);

方式2：通过FactoryBean动态创建Bean
实现FactoryBean接口，实现getObject()方法（返回DynamicService对象）。代码：
BeanDefinition factoryDef = BeanDefinitionBuilder
        .genericBeanDefinition(DynamicServiceFactory.class)
        .addConstructorArgValue(name)
        .getBeanDefinition();
registry.registerBeanDefinition("myFactoryBean", factoryDef);

@Configuration是配置类的注解，作用类似于传统xml文件，可以在其中定义bean及其他配置。加了这个注解的类会生成cglib代理对象，这个类中加了@Bean的方法返回的是单例bean
示例：
@Configuration
public class AppConfig {
    @Bean
    public MyService myService() {return new MyService(myRepository());}
    @Bean
    public MyRepository myRepository() {return new MyRepository();}
}
调用myService()方法时，myRepository()返回的是单例bean，而不会新建一个bean
如果把@Configuration换成@Component，则不会生成cglib代理对象而是原始对象，调用myService()方法时会创建新的MyRepository对象

ApplicationRunner
这是spring提供的一个类，在spring应用启动后执行特定的任务，且只会执行一次，可以做一些初始化操作，比如预热缓存，初始化db连接池。类似的还有CommandLineRunner

@PropertySource注解的作用
在类上加@PropertySource(value = "classpath:mytest.properties")，则该类下的属性会注入mytest.properties的值
@PropertySource的优先级【低于】application.properties
这种机制允许开发通过@PropertySource注解加载特定场景的配置

@ConfigurationProperties的作用
将配置文件中的属性值绑定到类的属性。比如配置文件 application.yml内容如下
user:
  name: "张三"
  age: 25

@ConfigurationProperties(prefix = "user") // 绑定前缀为 "user" 的配置
@Data
public class UserConfig {
    private String name;
    private Integer age;
}

bean初始化时执行自定义方法，有几种方式实现
1.@PostConstruct
2.实现InitializingBean接口的afterPropertiesSet()方法
3.@Bean(initMethod = "init") 在注解中指定initMethod方法，初始化时会执行init方法

spring为何不推荐使用@Autowired
1.如果字段是final，则无法注入（使用构造器可以解决）
2.隐藏了依赖关系，类应该公开它的依赖项
3.@Autowired可以解决循环依赖，但spring不希望开发依赖框架解决，而是重构代码解决循环依赖
推荐使用构造器和setter方法

spring如何解决跨域问题
什么是跨域问题？跨域是浏览器同源策略限制造成的，防止执行其他网站的脚本
如何判断是否同源？协议+域名+端口都相同，则同源，任一不同则不同源。http和https是不同的协议
跨域会阻止什么操作？1.接口调用 2.DOM查询（前端相关）
如何解决跨域问题：在响应头中添加key="Access-Control-Allow-Origin"，value="允许的协议+域名+端口"，浏览器会检查
spring解决跨域的方案：1.在方法上添加@CrossOrigin(origins = "http://example.com") 2.实现WebMvcConfigurer接口的addCorsMappings方法
