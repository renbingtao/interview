spring事务传播机制
一个spring事务执行中遇到了另一个spring事务，要如何处理事务间的关系。开启spring事务的时机：@Transactional注解被外部调用时，走proxy的增强方法，因此spring可以开启事务
方法自调用：举例controller->Aservice.a()->Aservice.b()。ab方法都有@Trancational注解，但自始至终都只有一个事物(a方法被调用时开启的)，因此不存在事务传播，b方法加不加注解效果都是一样的。b方法没有开启事务，是因为a调b时，是被代理类调用，因此不会走增强方法

spring事务传播的级别
required：默认，若当前存在事务则加入，不存在则新建
requireNew：无论当前事务是否存在，都新建事务，新老隔离
nested：若存在当前事务，则嵌套，否则新建
数据库一般都支持保存点（savePoint），允许在事务中设置一个标志点，回滚时只回滚到这个标志点而不是整个事务
spring的嵌套就是基于此实现的，开启嵌套事务时，在父事务中创建保存点，回滚时只回滚到这个保存点，不影响父事务之前的操作，但若父事务回滚，则子事务也会回滚
其他的不列出来了，一般都使用默认的级别

spring事务的实现方式
声明式事务：传统的事务实现中，需要手动地开启、提交、回滚。而spring声明式事务允许开发者通过声明的方式来定义事务，不需要手动编写代码来管理事务。具体实现是基于AOP，使用方式是XML或注解@Transactional
编程式事务：开发在业务代码中手动调用提交、回滚等操作。相比于声明式事务，更加灵活，但也更加难以维护

spring事务在多线程环境下生效吗
不。@Transactional注解使用ThreadLocal来保存事务上下文。事务传播也是依赖于当前线程的事务上下文
