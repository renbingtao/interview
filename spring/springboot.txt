springboot不需要独立的容器也能运行，因为内嵌了各种servlet容器如tomcat，不再需要打成war包，只需要打成jar包就能独立运行

springboot的核心注解是哪个
启动类上面的注解是@SpringBootApplication，它也是 Spring Boot的核心注解，它包含下列注解
@SpringBootConfiguration：继承自 @Configuration 注解，用于标记当前类是一个配置类
@EnableAutoConfiguration：自动配置的核心注解
@ComponentScan

spring boot是如何实现自动配置的
核心是@EnableAutoConfiguration，里面包含了两个注解：
1.@AutoConfigurationPackage
这个注解的作用说白了就是将主配置类（@SpringBootApplication标注的类）所在包以及子包里面的所有组件扫描并加载到spring的容器中，这也就是为什么我们在利用springboot进行开发的时候，无论是Controller还是Service的路径都是与主配置类同级或者次级的原因
2.@Import（AutoConfigurationImportSelector.class）
其中AutoConfigurationImportSelector实现了ImportSelector接口的selectImports方法，该方法一路调用下来，最终会查找所有在META-INF路径下的spring.factories文件，这些文件是k=v的形式，找到key=EnableAutoConfiguration的value（一个list）并返回，这些就是自动装配的配置类

如何理解starter
启动器，一站式解决依赖集合。传统的spring开发中，引入某个功能时，需要手动添加依赖并手动解决版本兼容问题，而使用starter只用添加一个starter依赖即可解决依赖及版本的问题
springboot的官方启动器都是以spring-boot-starter-命名的。要构建一个简单的 Web 应用，添加spring-boot-starter-web依赖即可

如何自定义一个starter
新建一个MyStarter工程，加入一个@Configuration类，声明各种bean。一般还要和@ConditionalOnXXX配合使用
2.7之前：src/main/resources/META-INF目录下新建spring.factories文件，该文件为k=v的格式，key=org.springframework.boot.autoconfigure.EnableAutoConfiguration，v为自己自定义的Configuration类，多个类以逗号分割
3.0之后：src/main/resources/META-INF/spring目录下新建org.springframework.boot.autoconfigure.AutoConfiguration.imports配置文件，内容为Configuration类的全路径，多个类以逗号分割
2.7-3.0两种都支持

为何springboot 3.0开始移除了spring.factories
为了支持云原生，为了提高启动速度。传统方式在运行时扫描并加载spring.factories，效率低。而3.0则是在编译时确定自动配置的类
为何3.0可以编译器确定，2.7之前只能运行期确定
2.7引入了@AutoConfiguration注解。imports配置文件下的@Configuration类，相当于添加了@AutoConfiguration注解。编译期间，spring会识别该注解，借助APT的方式实现生成代码
什么是APT
Annotation Processing Tool，java编译器的一个内置工具，可以在编译期间扫描和处理源代码中的注解，生成新的源文件或资源。比如Lombok的@Data注解

springboot配置加载顺序，上面的被下面的覆盖
@PropertySource注解指定的文件
application.yml
application.properties
操作系统环境变量
Java系统属性（System.getProperties()）
命令行参数
例：命令行和yml配置冲突，命令行的优先级更高

为何springboot的jar可以直接运行
springboot提供了插件spring-boot-maven-pulgin插件用于打成jar包
打出来的是Fat jar，包含各种jar包
java -jar会读取META-INF/MANIFEST.MF文件中的Main-Class（这是jvm的规范）的启动类JarLauncher
JarLauncher创建classloader并让它加载BOOT-INF/libs/下的jar包（各种starter就放在这里）
JarLauncher最终调用MANIFEST.MF文件中的Start-Class（springboot特有的）对应的启动类，即带有@SpringBootApplication注解的类
JarLauncher是springboot独有的，为了实现可独立运行的jar而设计的。传统的spring是没有这个的

spring boot启动流程
创建SpringApplication实例
    检查是否为web应用
    设置注册初始化器（BootstrapRegistryInitializer）默认0个
    设置上下文初始化器（ApplicationContextInitializer）默认7个
    设置应用监听器（ApplicationListener）默认8个
    备注：3个方法都是调用了getSpringFactoriesInstances(XX.class)，该方法会调用classLoader.getResources（传入的参数为常量META-INF/spring.factories）来获取全部资源（无论它们在哪，哪怕是jar包内），然后实例化
调用SpringApplication的run方法（下面都展示实际的方法名）
    createBootstrapContext
        创建启动上下文，并逐一加载BootstrapRegistryInitializer
    getRunListeners
        从spring.factories配置文件中获取SpringApplicationRunListener的集合，其中最主要的是EventPublishingRunListener
    listeners.starting
        发布【starting事件】。其中EventPublishingRunListener会把该事件转换成spring标准事件SpringApplicationEvent，然后发布
    prepareEnvironment
        getOrCreateEnvironment
        configureEnvironment
            配置属性源，比如环境变量，jvm参数等，并放在propertySources中
            激活配置文件（profiles），根据环境（dev，sit，prd）加载不同的配置
            处理命令行参数，如 --server.port=8080
        发布【environmentPrepared事件】：EnvironmentPostProcessorApplicationListener会串行执行的EnvironmentPostProcessor
    printBanner
    createApplicationContext
        默认是servlet web上下文
    prepareContext
        postProcessApplicationContext
            设置beanNameGenerator、resourceLoader、addConversionService
        applyInitializers
            执行初始化器，即ApplicationContextInitializer
            createBeanDefinitionLoader
                创建bean定义加载器并加载bean定义，放入beanDefinitionMap（ConcurrentHashMap）。这里只加载了少数bean定义，主要是启动类，即@SpringApplication标注的类
        发布【contextLoaded事件】
    refreshContext
        即IOC的创建流程或者说自动装配bean，比较复杂，放在后面
    listeners.started
        发布【started事件】
    callRunners
        调用CommandLineRunner或ApplicationRunner接口（这两个都是Runners的子类）

ApplicationContext refresh的流程
代码实现位于AbstractApplicationContext
1.环境准备
prepareRefresh：对servletContextInitParams和servletConfigInitParams参数赋值，并校验是否有必填的环境变量
2.容器处理
obtainFreshBeanFactory：创建或获取一个新的BeanFactory实例，对于spring boot来说相当于空方法
prepareBeanFactory：
    setBeanClassLoader
    setBeanExpressionResolver（表达式解析器）
    addPropertyEditorRegistrar（配置文件处理器）
    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));（用来解析aware接口）
    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));（用来注册内部bean作为事件监听器）
postProcessBeanFactory：对BeanFactory做一些额外处理，主要是注册scope，注册servlet相关的bean
invokeBeanFactoryPostProcessors：逐一调用BeanFactoryPostProcessor，包括很重要的ConfigurationClassPostProcessor：用来加载所有@Configuration配置类及内部注解（比如@Bean，@ComponentScan，@Import）并转化为bean定义，放入beanDefinitionMap
registerBeanPostProcessors：注册（不是使用）BeanPostProcessor并排序。这些BeanPostProcessor在bean初始化前后进行额外的处理
3.bean处理
initMessageSource：初始化MessageSource，可用于国际化
initApplicationEventMulticaster：初始化事件广播器，用于发布和处理应用程序事件
onRefresh：构造并启动web服务器，默认是tomcat
registerListeners：查找并注册所有实现了ApplicationListener接口的Bean，将它们注册到事件广播器（即ApplicationEventMulticaster）中，以便监听和处理应用程序事件
finishBeanFactoryInitialization：创建所有剩余的单例Bean，即构造对象，填充属性，初始化，注册销毁。bean生成后会放入单例池singletonObject中
finishRefresh：
    initLifecycleProcessor：初始化生命周期管理器
    getLifecycleProcessor().onRefresh()：调用所有实现了LifecycleProcessor接口的bean的onRefresh方法，最后会Lifecycle接口的调用start方法（容器关闭时也会调用对应的stop方法）
    publishEvent(new ContextRefreshedEvent(this))：发布容器刷新完成事件

BootstrapContext是什么及作用
BootstrapContext是spring boot的启动阶段的早期的、临时的上下文，用来管理早期必需的基础组件，比如配置文件解析器

SpringApplicationRunListeners是什么及作用
它是事件发布与监听的协调者，不负责具体的业务逻辑。在spring boot启动的各个阶段，发布各种事件并通知监听器，执行自定义的逻辑。常见的事件如下：
starting，environmentPrepared，contextPrepared，contextLoaded，started
