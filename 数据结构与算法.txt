
========================表、栈和队列========================

表（list）比较简单，跳过

栈（stack）
栈是限制插入和删除只能在一个位置上进行的表（list），该位置是表的末端，叫做栈的顶（top）。对栈的基本操作有push（进栈）和pop（出栈）。栈有时又叫做LIFO（后进先出）表。栈一般的模型是，存在某个元素位于栈顶，而该元素是唯一的可见元素
栈的实现
由于栈是一个表，因此任何实现表的方法都能实现栈，包括ArrayList 和LinkedList，前者更加流行。栈很可能是计算机科学中在数组之后的最基本的数据机构
栈的应用
1.平衡符号
编译器检查程序的语法错误时，经常检查符号是否成对出现，比如[()]是合法的，([)]是非法的。
这个算法用到一个栈：创建一个空栈，读入全部字符，若字符为开放符号，比如"("，则push；若字符是封闭符号，栈为空则报错，否则pop，若pop出的符号不是对应的开放符号。在结尾，若栈为非空则报错
2.后缀表达式
计算4.99*1.06+5.99+6.99*1.06，可将操作书写如下：4.99 1.06 * 5.99 + 6.99 1.06 * +
这个记法叫做后缀（或逆波兰）记法。对于后缀表达式的计算，可用栈解决：遇到一个数就push，遇到计算符号就pop出两个，将计算结果push，最后栈中只有一个元素，即结果
中缀到后缀的转换
假设有中缀表达式（也叫做标准形式的表达式）：a+b*c+(d*e+f)*g，将其变成后缀表达式，结果为abc*+de*f+g*+ 过程复杂跳过
3.方法调用
调用新方法时，主调例程的所有局部变量都要存储，包括当前位置也要存储，以便新方法运行完后向哪里跳转。这个问题和平衡符号很类似，方法调用和方法返回类似于开括号和闭括号

队列（queue）
队列也是表，但使用队列时，插入在一端进行，删除在另一端进行
队列的基本操作包括：enqueue（入队），在表的末端（或队尾）插入一个元素；dequeue（出队），删除并返回表的开头（或队头）的元素
队列的应用
访计算机用户访问文件服务器（file server）中的文件是按照先到先得的原则访问，因此其数据结构是一个队列

========================树========================

树的遍历
private void listAll(int depth){
    printName(depth)
    if(isDirectory()){
        foreach(file c:directory){
            c.listAll(depth+1)
        }
    }
}
上述遍历策略称为【先序遍历】，即对节点的处理是在它的诸多儿子节点被处理之前进行的
另一种遍历方法时【后序遍历】，即先处理儿子节点，再处理本节点

二叉查找树
对于树中的每个节点X，它的左子树所有项的值小于X中的项，右子树中所有项的值大于X中的项。【中序遍历】：先处理左子树，然后当前节点，最后处理右子树

伸展树
本质上是二叉查找树，它的特点是把最近访问的节点移动到根节点，后续访问相同节点时能减少时间开销，所以很适合缓存

平衡二叉树
最矮的树和最高的树高度差最多为1，即平衡因子=左子树高度-右子树高度的绝对值<=1。不平衡时，再判断不平衡的子树是左节点还是右节点插入导致的不平衡。
LL型(平衡因子=2且子树的平衡因子=1)右旋，RR同理左旋；LR型（平衡因子=2且子树的平衡因子=-1）左右旋，同理RL型右左旋。
查询时间复杂度O（log n），n为节点总数
适用于插入删除少，查询多的场景

红黑树
由于平衡二叉树对高度差的要求很高，需要频繁旋转，插入性能差，因此定义了红黑树，减少旋转次数。最高的树的高度最多是最矮的树的高度的2倍。
规则：是搜索树（左根右）。每个节点为红或者黑。根及叶子节点为黑，这里的叶子节点指的是最下面的节点下的null节点。连续两个节点不能为红。根到叶子节点（null）的黑色节点总数一致。
规则总结为：左根右，根叶黑，不红红，黑路同
插入时，默认插入红色节点。当不满足规则时，进行判定：叔叔节点是红还是黑？如果是红色，则父叔爷三个节点变色（红变黑，黑变红），同时爷爷节点变为插入节点，重复上述操作；如果是黑色，进行LL、RR等旋转（参考平衡二叉树），然后对旋转点及中心点进行变色

B树
B树为M叉查找树，即节点最多有M个子节点，阶为M（二叉树的阶为2）
节点的扇出在M/2到M之间
所有叶子节点的高度一致；内部节点包含关键字、记录指针、指向下一节点的指针
所有节点的关键字都是从小到大排序

B+树
B树的升级版，内部节点不保存记录指针，使得扇出变大，树矮胖。适合内存有限

贪心算法与动态规划的区别
贪心算法追求局部最优解，划分的每个子问题都最优，但不能保证全局最优
动态规划：将问题分解为重复的子问题，每次都寻找左右子问题解中最优的解，一步步得到全局最优解。重复的子问题可以记录下来，避免重复计算
比如钱币分为1、3、4元，要6元，贪心先拿4，再拿两个1；而动态规划拿两个3

分治法
与动态规划类似，将大问题分解为小问题，但这些小问题是独立的
