存储器的多层结构
CPU寄存器： 寄存器
主存：     高速缓存（cpu一级二级三级缓存）、主存储器（通常理解的内存）、硬盘缓存（硬盘的一部分）
辅存：     固定磁盘、可移动存储介质（U盘）

无存储器抽象
早期计算机没有存储器抽象，每个程序都是直接操作物理内存
当时呈现给编程人员的存储器模型就是简单的物理内存：0-某个上限的地址集合，每个地址对应一个存储单元，可容纳n（通常是8）个二进制数
想要同时运行多个程序，操作系统需要把当前内存中所有内存保存到磁盘文件中，把下一个程序读入内存再运行即可

程序的装入
绝对装入：适用于单道程序的系统，由程序员手动指定将程序加载到物理内存的绝对地址
可重定位装入：适用于多道程序，程序访问的是相对地址（每个地址都加上一个偏移量）
动态运行时装入
前两种需要一次性将全部程序都加载到内存中

存储器抽象：地址空间
地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有自己的地址空间，这个地址空间和其他进程的地址空间独立（除非需要共享）
早期使用【基址寄存器】+【界限寄存器】。给每个CPU分配这两个寄存器。当一个程序运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。进程访问内存时，CPU在把地址发送到内存总线前，自动把基址值加到进程操作的地址上，同时检查地址是否大于等于界限寄存器里的值。大于则产生错误
这种方式的缺点是：每次访问内存都需要加法和比较（比较可以很快，但加法很慢）

交换技术
程序需要的内存总和通常远大于物理内存。应对方案：
最简单的是交换技术，即把一个进程完整调入内存，运行一段时间，然后保存回磁盘（具体说是磁盘缓存）
交换技术不是一个有吸引力的方案，因为磁盘的速度太慢
另一种是虚拟内存

虚拟内存
基本思想是：每个程序有自己的地址空间，这个空间被分割成多个【块】，每个块称作【页】或【页面】（page），每一页有连续的地址范围。这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序。当程序使用在物理内存中的地址空间时，由硬件执行映射；当引用不在物理内存中的地址空间时，由操作系统将缺失的部分装入物理内存并重新执行失败的指令
程序执行MOV REG,1000时，把地址=1000的内存单元的内容复制到REG中。由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。在没有虚拟地址空间的计算机上，系统直接把虚拟地址送到内存总线上，使用同样地址的物理内存；使用虚拟内存的情况下，虚拟地址被送到内存管理单元MMU（memory management unit），MMU再把虚拟地址映射为物理内存地址。通常情况下，MMU是CPU芯片的一部分
虚拟地址空间的单元为页面，物理内存对应的单元为【页框】。页面和页框通常是大小一样的
在硬件中，用一个在/不在的位来表示页面是否映射到物理内存
如果操作没有映射到物理内存的页，则CPU陷入到操作系统，这个陷阱称为【缺页中断】或者【缺页错误】。操作系统找到一个很少使用的页框并把它的内容写入磁盘，然后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新执行指令

页面置换算法
LRU
理想的LRU：可以参考linkedHashMap。内存中维护一个所有页面的链表，最近最少使用的页面在表头。困难之处在于找到页面，删除，移动至头部是非常耗时的操作
模拟LRU的算法：老化算法。为每一个页面关联一个【置换计数器】（比如0101010），每经过一个时钟滴答，计数器右移1位并在左端插入R位（访问位，0或1）。发生缺页中断时，将置换计数器最小的页面置换
