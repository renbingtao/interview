存储器的多层结构
CPU寄存器： 寄存器
主存：     高速缓存（cpu一级二级三级缓存）、主存储器（通常理解的内存）、硬盘缓存（硬盘的一部分）
辅存：     固定磁盘、可移动存储介质（U盘）

无存储器抽象
早期计算机没有存储器抽象，每个程序都是直接操作物理内存
当时呈现给编程人员的存储器模型就是简单的物理内存：0-某个上限的地址集合，每个地址对应一个存储单元，可容纳n（通常是8）个二进制数
想要同时运行多个程序，操作系统需要把当前内存中所有内存保存到磁盘文件中，把下一个程序读入内存再运行即可

程序的装入
绝对装入：适用于单道程序的系统，由程序员手动指定将程序加载到物理内存的绝对地址
可重定位装入：适用于多道程序，程序访问的是相对地址（每个地址都加上一个偏移量）
动态运行时装入
前两种需要一次性将全部程序都加载到内存中

存储器抽象：地址空间
地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有自己的地址空间，这个地址空间和其他进程的地址空间独立（除非需要共享）
早期使用【基址寄存器】+【界限寄存器】。给每个CPU分配这两个寄存器。当一个程序运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。进程访问内存时，CPU在把地址发送到内存总线前，自动把基址值加到进程操作的地址上，同时检查地址是否大于等于界限寄存器里的值。大于则产生错误
这种方式的缺点是：每次访问内存都需要加法和比较（比较可以很快，但加法很慢）

交换技术
程序需要的内存总和通常远大于物理内存。应对方案：
最简单的是交换技术，即把一个进程完整调入内存，运行一段时间，然后保存回磁盘（具体说是磁盘缓存）
交换技术不是一个有吸引力的方案，因为磁盘的速度太慢
另一种是虚拟内存

虚拟内存
基本思想是：每个程序有自己的地址空间，这个空间被分割成多个【块】，每个块称作【页】或【页面】（page），每一页有连续的地址范围。这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序。当程序使用在物理内存中的地址空间时，由硬件执行映射；当引用不在物理内存中的地址空间时，由操作系统将缺失的部分装入物理内存并重新执行失败的指令
程序执行MOV REG,1000时，把地址=1000的内存单元的内容复制到REG中。由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。在没有虚拟地址空间的计算机上，系统直接把虚拟地址送到内存总线上，使用同样地址的物理内存；使用虚拟内存的情况下，虚拟地址被送到内存管理单元MMU（memory management unit），MMU再把虚拟地址映射为物理内存地址。通常情况下，MMU是CPU芯片的一部分
虚拟地址空间的单元为页面，物理内存对应的单元为【页框】。页面和页框通常是大小一样的
在硬件中，用一个在/不在的位来表示页面是否映射到物理内存
如果操作没有映射到物理内存的页，则CPU陷入到操作系统，这个陷阱称为【缺页中断】或者【缺页错误】。操作系统找到一个很少使用的页框并把它的内容写入磁盘，然后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新执行指令

页面置换算法
LRU
理想的LRU：可以参考linkedHashMap。内存中维护一个所有页面的链表，最近最少使用的页面在表头。困难之处在于找到页面，删除，移动至头部是非常耗时的操作
最重要最好的是下面两种算法
老化算法：为每一个页面关联一个【置换计数器】（比如0101010），每经过一个时钟滴答，计数器右移1位并在左端插入R位（访问位，0或1）。发生缺页中断时，将置换计数器最小的页面置换
工作集时钟算法：数据结构是以页框为元素的循环表。开始为空，页面装入后，加入到表中。随着页面的加入，它们形成了一个环。每个表项包含上次使用时间、R位、M位（修改位）。缺页中断发生时，检查指针指向的页面，如果R=1，则set R=0，指针指向下一个页面，并重复。如果R=0，如果页面的生存时间>阈值t且页面是干净的，它就不在工作集中，且磁盘上有副本，那么申请此页框，并把新页面放入其中；如果页面被修改过，则不能申请，指针指向下一个

内存映射文件
进程通过发起一个系统调用，将一个文件映射到其虚拟地址空间的一部分。在大部分实现中，在映射共享的页面时不会真正读入页面的内容，而是访问页面时才会被一页一页地读入（懒加载）。进程退出或显式地解除文件映射时，所有被改动的页面会被写回磁盘文件中

非连续分配的方式
1.基本分页存储管理方式
把物理内存按照固定大小分成若干个块。页表一般保存在内存中
地址由【页号】和【页内偏移量】组成

2.基本分段存储管理方式
按用户进程的地址空间进行划分。一个进程可能包含若干个模块，比如主程序、子进程、公共程序等，如果这些模块都放在一起，不好管理。因此可以把用户进程的地址空间按模块划分为多个【段】，用来管理逻辑内存。每个段的地址都是从0开始，大小不固定且可以运行期动态改变
地址由【段号】和【段内地址】组成
由编译器实现，保存在【段表寄存器】中（实际的段表很小），使用高级语言了解即可
段表示例
段号     段长        基址（对应物理内存的起始地址）
0       7k          55k
1       3k          63k
2       10k         30k
逻辑地址由段号（高16位）+段内地址（低16位）组成
段的共享：同一个物理段被多个子进程都添加到自己的段表中，从而被多个子进程共享

分页与分段的对比
页：物理单位      一维地址空间
段：逻辑单位      二维地址空间      分段更容易信息共享和保护
页是一维是指页只需要维护页号-始址的关系；段是二维是指段要额外维护段长

3.段页式管理
分页和分段是可以同时存在的。分段，然后把每一个段当成虚拟内存进行分页
段页式的逻辑地址=16位段号+4位页号+12位页内偏移
段页式需要两张表：段表和页表
段表项：段号、页表长度、页表存放块号（物理块号）
页表项：页号、块号（也是物理块号）
举例：
段号      页表长度    页表存放块号
0           2           1
1
2
1号块的页表
页号      块号
0         k0
1         k7
页表存放块号1、块号k0、块号k7都是物理块

段表寄存器
包含【段表始址】+【段表长度】。注意段表本身是在内存中，通过段表寄存器快速知道段表保存在内存的什么位置

段页式寻址过程
1.对逻辑地址进行位运算，得到段号
2.通过段表寄存器的段表始址+段号，得到段表项（上面例子通过0段号找到段表项0-2-1）
3.通过页表地址（即页表存放块号）+页号找到页表项（通过物理块1+页号0找到k0）
4.内存块号+页内地址（业内偏移量）找到物理地址（k0是一个物理块，保存实际数据，还需要块内的偏移量找到具体的地址）

段页表会占用物理内存，但占比很低：最坏情况下虚拟内存全部使用，段页表也仅占物理内存的0.2%
