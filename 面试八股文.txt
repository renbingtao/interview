
========================java基础========================

java创建对象的几种方式
new，反射，clone，反序列化。前两个会调用构造方法，后两个不会。其中反序列化需要对象实现serializable接口（这是一个空接口），通过ObjectInputStream.readObject方法创建

transient的作用
序列化时忽视

0.1*3和0.3是否相等
不，java默认使用double保存，0.1和0.3都无法精确表示

a=a+b和a+=b的区别
a为short，b为int，相加时会隐式地将short提升为int，即结果为int。a=a+b会报错，无法用short接收int；a+=b会将结果强制转化为short，不会报错

try catch finally及return的执行顺序
先执行try或catch，在return前保存结果，执行finally，再返回之前保存的结果（基本数据类型是保存值，对象则保存引用）。但若finally中return，则不会返回之前保存的记过

IO流
可分为输入流和输出流，也可分为字符流和字节流。

Object常用的方法
wait，配置sync关键字，一个线程在获取锁后，执行wait方法会手动释放锁，等待其他线程唤醒它。notify，配合sync关键字，唤醒wait的某个线程（但此时没有释放锁，只是通知其他线程可以抢锁了）。notifyall，唤醒全部线程。

实现两个线程交替执行
while循环里执行业务代码，然后notify，然后wait。循环外notify。

fail-fast
java集合的一种错误机制，多个线程同时操作同一个集合对象时，可能产生fail-fast事件，抛出异常。遍历前记录modCount（记录集合修改的次数），遍历时比较该值是否有改变，有则说明被修改，抛异常。

concurrentHashMap原理
java8之前，分段锁
8及之后采用cas+synchronized关键字。读时无锁，通过volatile保证可见性。写时，使用sync关键字对头节点加锁，头节点为空时，通过cas写入；不为空时死循环写入。

cas锁
比较并交换值，这是一个系统底层的原子方法，不可分割的

线程池的生命周期
创建：没有任务运行
运行：任务提交到线程池
关闭：不再接收新任务，但已有的任务继续执行（包括阻塞队列中的任务）
终止：所有任务执行完毕

并发与并行
并发：单核处理器在多个程序之间快速切换
并行：同一时刻多个任务同时执行，需要多核处理器

进程通信的方式：共享存储、消息传递、管道通信
消息传递：直接通信（点到点发送，通过send和receive原语，每个进程维护消息缓冲队列）和间接通信（广播信箱为中介，类似消息队列）
管道通信：管道的本质是一个共享pipe文件，是内存中固定大小的缓冲区
进程的状态：ready、running、blocked、new、terminated。上面5种为线程活跃（alive）时的状态，此外还有挂起（suspend）和激活（active）两个原语用于控制进程。

========================多线程及并发========================

创建线程的方式
继承Thread并重写run方法
实现Runnable接口并作为参数传给thread
实现Callable接口并作为参数传给FutureTask，再把FutureTask传递给thread
线程池创建任务实现Runnable或Callable

如何停止一个正在运行的线程
使用自定义的标识，即正常退出；stop强行停止，已废弃；interrupt，设置标志位，线程并不会立即停止，而是在合适的时机检查标志位

java线程池中常用的队列有哪些
下面三个都是guc下的
ArrayBlockingQueue，基于数组的有界阻塞队列，FIFO，创建时指定大小，线程安全，通过add（抛异常）、offer（返回false）、put（线程被阻塞直到有空位）方法插入元素，括号内为队列满时的处理方式；通过poll（返回null）、take（线程等待）获取并移除头部的元素
LinkedBlockingQueue，基于链表的有界或可选无界的阻塞队列，FIFO，不指定容量时为整数最大值
SynchronousQueue，特殊的队列，容量为0，元素直接从生产者给消费者，无缓冲。Executors.newCachedThreadPool()内部就使用了该队列，适合大量短期异步任务，潜在问题是允许创建的线程无上线，可能耗尽系统资源。应用场景：线程之间直接传递数据，没有延迟

threadLocal
使用弱引用的原因：若使用强引用，threadlocal对象的引用设置为null时，threadlocalmap仍指向了threadlocal对象，导致不会回收，使用弱引用则会正常回收
内存泄露的原因：threadlocal对象被回收后，map的key为null，但值仍存在，生命周期和线程一致。所以使用完threadlocal后，要调用remove清除键值对。另外线程可能复用，若不清除，线程下次复用时，threadlocal仍保存之前的值，导致混乱

AQS
一个抽象类，位于guc的Lock包下，为锁和同步器提供了通用的框架。提供了排他锁和共享锁、公平锁和非公平锁等制。使用了int类型的state变量记录锁竞争的状态，不同子类实现中有不同的含义
在reentrantLock中，state 0表示没有线程竞争锁资源，>=1表示有线程持有锁
线程获取锁时，若state=0，使用cas更新为1，多个线程同时抢锁时，抢锁失败的线程会调用Unsafe.park方法进行阻塞，打包成node节点（双向链表，FIFO，包含Thread属性），插入到链表的末尾；锁释放后，会唤醒双向链表头一个阻塞的线程（并不是头节点，头节点是傀儡节点）
公平锁和非公平锁的区别：两者在获取锁时都会判断state是否为0，公平锁还会判断队列中是否有阻塞的线程，然后cas一次进行抢锁

========================分布式========================

对CAP的理解
正常情况下，一个集群内的节点之间是可以正常通信的，异常时某些节点之间无法通信，可能导致无法获取需要的数据，这是无法容忍的，因此把节点多复制几份，一个节点无法访问，但可以访问其他节点的，这就是分区容错性
然而要保证多个节点之间数据是相同的，这就带来了一致性问题，要保证一致性，写数据时要保证所有节点都写成功
保证一致性又会带来可用性问题，因为操作时间变长了。
总之，节点越多，分区容错性越高；分区容错高了，一致性又难保证；一致性保证了，可用性又难保证

分布式幂等性如何设计
查询和删除不在讨论范围之内
1.建立唯一索引
2.token机制。进入下单页前端请求后台，获取token，后台将token放入redis并设置ttl。用户下单时带上token，后台校验token是否有效，有效时更新redis的状态为处理中，然后执行业务代码，这样当用户误点击导致重复提交时，后台校验redis发现状态为处理中，则返回请勿重复提交

限流算法
计数器算法（固定窗口）：使用计数器在周期内累加，达到限流值时丢弃，下一周期开始时清零
滑动窗口：将周期分为多个小周期，分别记录每个小周期内的次数，并根据时间删除小周期
漏桶：一个底部有洞的桶，请求像水一样注入到桶中，以恒定的速率流出桶，桶满时丢弃，一般用队列实现
令牌桶：以固定的速度向令牌桶中扔令牌，直到桶满；请求需要先获取令牌才能继续，否则被丢弃

========================网络及安全========================

TCP三次握手
第一次：客户端->服务器，SYNC=1，生成随机序列号ISN A
第二次：服务器->客户端，SYNC=ACK=1，生成ISN B，同时ack number=A+1
第三次：客户端->服务器，ACK=1，ack number=B+1，ISN=A+1
为何需要三次握手：由于网络不稳定，发送的TCP包可能经过很长时间才能到达，客户端会重传，之后旧的TCP包到达。如果没有三次握手，服务器会以为这是新发起的一个请求，并建立连接。有了三次握手，服务器会向客户端确认，由于客户端并没有真的发起请求，所以不会理会，避免了建立连接。
半连接队列：服务器收到第一次握手的TCP报文时，在半连接队列中创建一个条目，此时连接处于SYN_RECV状态。队列满时，可能会丢弃后续的TCP报文，或采取其他策略，如调整队列大小。
全连接队列：三次握手成功后连接从半连接队列转移至全连接队列。


传统手写签名有两个作用
1.证明签名者的身份（笔迹鉴定）2.表明签名者认可签名的内容（肉眼观察）。数字签名有同样的作用，但实现方式不同：1.使用数字证书证明身份2.对比文件hash值

数字签名
签名过程：小明对明文计算摘要（sha256），然后用私钥加密得到密文，将明文、密文、公钥一同发布到互联网。计算摘要是为了提高效率，同时有些算法无法处理太长的明文
验证过程：小红用公钥解密，得到摘要A，对明文计算摘要得到B，比较AB是否相等
缺陷：数字签名可以保证内容不被篡改，但无法保证公钥为小明创建的。

数字证书
作用是证明公钥的生成者为小明。小明将公钥及身份信息发给权威的CA机构，CA颁发给小明一个证书，其中包含了公钥和身份信息，并用CA私钥加密。小明将证书发布到互联网，小红就可以通过CA公钥证明哪个证书是小明的，从而确定公钥。
如何保证数字证书不是伪造？数字证书由CA签名，CA有自己的公私钥，每人的电脑里有CA根证书，放在浏览器或操作系统里，记录了可信赖的CA机构信息及公钥。

https
tcp连接创立后进入https的加密流程。流程：1.TLS通过4次握手获取会话秘钥 2.基于秘钥进行对称加密通信。
四次握手：
1.客户端发送给服务端，包括支持什么加密协议版本、 算法及一个随机数A
2.服务端发给服务端，具体的加密方式、服务器证书、随机数B
3.客户端从证书中取得服务器公钥，生成随机数C，用公钥对C加密发给服务端。客户端用ABC计算得到会话秘钥，将迄今为止的通信数据算一个摘要（也叫finished报文），用会话秘钥加密发给服务端做校验
4.服务端使用服务器私钥解密，得到C，对ABC使用同样的算法得到会话秘钥，同样对迄今为止的数据算摘要发给客户端做校验。
后续双方就使用这个会话秘钥进行对称加密通信。不使用非对称加密是因为慢；使用3个随机数是为了加大随机性，使秘钥更难被破解

自己签名的不受信任证书要安装在客户端

https不是绝对安全的，https只能解决端到端的传输安全问题，如果客户端本身已经被入侵，即端已经被入侵，并被安装了伪造的根证书，那https也是不安全的

========================设计模式========================

创建型模式：单例、原型、建造者、工厂
结构型模式：适配器、桥接、组合、装饰器、外观、代理、享元
行为型模式：责任链、命令、迭代器、中介者、备忘录、解释器、状态、策略、模板方法、访问者、观察者

原型模式
复制现有对象来创建新对象，而不是使用实例化

装饰器
基于接口，使用组合而非继承的模式，动态地拓展功能

外观
为一组接口提供一个统一、简单的高层接口，隐藏了子系统的复杂性。比如吃饭，正常调用买菜、洗菜、做饭等一系列复杂接口，使用外观模式，只需要调用下单接口

代理和装饰器的区别
两者在结构上很接近，代理的重点是隐藏被代理对象；装饰器的重点是拓展原有功能

责任链
如名称，将请求的处理者连成一个链条，每个处理者可以自己处理请求，也可以交给下一个处理者。常见于审批流程

策略
定义一个策略接口，用来表示算法。有若干实现类。上下文根据客户端选择不同的策略，避免修改代码
java中集合类的排序器Comparator就是策略模式，定义一个排序接口，由客户端自行实现，无需修改Comparator本身代码
常用于支付方式选择、优惠券选择等

设计模式背后的思想
封装变化：将可能变化的地方独立出来，不要和不变的地方混合在一起。比如策略模式、模板方法模式
开闭原则：对拓展开发，对修改关闭。有新需求时，不修改原有的代码，而是通过拓展实现。比如装饰器模式
依赖倒置原则：高层模块不应依赖具体的底层依赖，而是依赖抽象；抽象不应依赖细节，细节应依赖抽象
单一职责原则：一个类应只有一个引起它变化的原因，即一个类只负责一个职责
组合复用原则：尽量使用组合或聚合，而不是继承
里氏替换原则：子类可以在任意地方替换父类，而不影响功能。长方形为父类，正方形为子类，显然不符合该原则
迪米特法则：也叫最少知道原则，一个对象应对其他对象有最少了解，即一个类应减少与其他类的直接交互。比如学生-班级-学校三个类，学校有遍历全部学生的方法。不符合法则的写法：学校的方法内部，使用两个for循环遍历。正确的写法：班级提供遍历学生的方法A，学校使用一个for循环调用A
